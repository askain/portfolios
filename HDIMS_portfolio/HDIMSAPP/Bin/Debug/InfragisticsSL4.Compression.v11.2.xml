<?xml version="1.0"?>
<doc><!--11.2.20112.1010-->
    <assembly>
        <name>InfragisticsSL4.Compression.v11.2</name>
    </assembly>
    <members>
        <member name="T:Infragistics.CodePage437Encoding">
            <summary>
            Implementation of Code page 437 encoding
            </summary>
        </member>
        <member name="T:Infragistics.CodePageSingleByte">
            <summary>
            Encoding for code pages that have single byte representation
            </summary>
        </member>
        <member name="T:Infragistics.CodePageEncoding">
            <summary>
            Implementation for missing code pages support
            </summary>
        </member>
        <member name="M:Infragistics.CodePageEncoding.GetEncoding(System.Int32)">
            <summary>
            Gets the encoding.
            </summary>
            <param name="codePage">The code page.</param>
            <returns>The Encoding for the code page specified or throw ArgumentException if code page is not supported</returns>
        </member>
        <member name="M:Infragistics.CodePageEncoding.GetCodePage(System.Text.Encoding)">
            <summary>
            Gets the code page. Replaces Encoding.CodePage;
            </summary>
            <param name="encoding">The encoding.</param>
            <returns>The code page of the encoding</returns>
        </member>
        <member name="P:Infragistics.CodePageEncoding.CodePage">
            <summary>
            Gets the code page.
            </summary>
            <value>The code page.</value>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.#ctor(System.Int32,System.Nullable{System.Char}[])">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.CodePageSingleByte"/> class.
            </summary>
            <param name="codePage">The code page.</param>
            <param name="codePageLayout">The code page layout.</param>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <param name="byteIndex">The zero-based Index of the first byte to decode.</param>
            <param name="byteCount">The number of bytes to decode.</param>
            <param name="chars">The character array to contain the resulting set of characters.</param>
            <param name="charIndex">The zero-based Index at which to start writing the resulting set of characters.</param>
            <returns>
            The actual number of characters written into <paramref name="chars"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="bytes"/> is null.-or- <paramref name="chars"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="byteIndex"/> or <paramref name="byteCount"/> or <paramref name="charIndex"/> is less than zero.-or- <paramref name="byteIndex"/> and <paramref name="byteCount"/> do not denote a valid range in <paramref name="bytes"/>.-or- <paramref name="charIndex"/> is not a valid Index in <paramref name="chars"/>. </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="chars"/> does not have enough capacity from <paramref name="charIndex"/> to the End of the array to accommodate the resulting characters. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetChars(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <param name="index">The zero-based index of the first byte to decode.</param>
            <param name="count">The number of bytes to decode.</param>
            <returns>
            A character array containing the results of decoding the specified sequence of bytes.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="bytes"/>. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetChars(System.Byte[])">
            <summary>
            When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <returns>
            A character array containing the results of decoding the specified sequence of bytes.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetMaxByteCount(System.Int32)">
            <summary>
            When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.
            </summary>
            <param name="charCount">The number of characters to encode.</param>
            <returns>
            The maximum number of bytes produced by encoding the specified number of characters.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="charCount"/> is less than zero. </exception>
            <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetMaxCharCount(System.Int32)">
            <summary>
            When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.
            </summary>
            <param name="byteCount">The number of bytes to decode.</param>
            <returns>
            The maximum number of characters produced by decoding the specified number of bytes.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="byteCount"/> is less than zero. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for a complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetByteCount(System.Char[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.
            </summary>
            <param name="chars">The character array containing the set of characters to encode.</param>
            <param name="index">The zero-based Index of the first character to encode.</param>
            <param name="count">The number of characters to encode.</param>
            <returns>
            The number of bytes produced by encoding the specified characters.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="chars"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="chars"/>. </exception>
            <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.
            </summary>
            <param name="chars">The character array containing the set of characters to encode.</param>
            <param name="charIndex">The zero-based Index of the first character to encode.</param>
            <param name="charCount">The number of characters to encode.</param>
            <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
            <param name="byteIndex">The zero-based Index at which to start writing the resulting sequence of bytes.</param>
            <returns>
            The actual number of bytes written into <paramref name="bytes"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="chars"/> is null.-or- <paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="charIndex"/> or <paramref name="charCount"/> or <paramref name="byteIndex"/> is less than zero.-or- <paramref name="charIndex"/> and <paramref name="charCount"/> do not denote a valid range in <paramref name="chars"/>.-or- <paramref name="byteIndex"/> is not a valid Index in <paramref name="bytes"/>. </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="bytes"/> does not have enough capacity from <paramref name="byteIndex"/> to the End of the array to accommodate the resulting bytes. </exception>
            <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetCharCount(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <param name="index">The zero-based Index of the first byte to decode.</param>
            <param name="count">The number of bytes to decode.</param>
            <returns>
            The number of characters produced by decoding the specified sequence of bytes.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="bytes"/>. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageSingleByte.GetString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <param name="index">The zero-based Index of the first byte to decode.</param>
            <param name="count">The number of bytes to decode.</param>
            <returns>
            A <see cref="T:System.String"/> containing the results of decoding the specified sequence of bytes.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="bytes"/>. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="P:Infragistics.CodePageSingleByte.CodePage">
            <summary>
            Gets the code page.
            </summary>
            <value>The code page.</value>
        </member>
        <member name="M:Infragistics.CodePage437Encoding.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.CodePage437Encoding"/> class.
            </summary>
        </member>
        <member name="T:Infragistics.CodePageDoubleByte">
            <summary>
            Encoding for code pages that have double byte representation
            </summary>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.#ctor(System.Int32,System.Collections.Generic.Dictionary{System.Int32,System.Nullable{System.Char}[]})">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.CodePageDoubleByte"/> class.
            </summary>
            <param name="codePage">The code page.</param>
            <param name="codePageLayouts">The code page layouts.</param>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <param name="byteIndex">The zero-based Index of the first byte to decode.</param>
            <param name="byteCount">The number of bytes to decode.</param>
            <param name="chars">The character array to contain the resulting set of characters.</param>
            <param name="charIndex">The zero-based Index at which to start writing the resulting set of characters.</param>
            <returns>
            The actual number of characters written into <paramref name="chars"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="bytes"/> is null.-or- <paramref name="chars"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="byteIndex"/> or <paramref name="byteCount"/> or <paramref name="charIndex"/> is less than zero.-or- <paramref name="byteIndex"/> and <paramref name="byteCount"/> do not denote a valid range in <paramref name="bytes"/>.-or- <paramref name="charIndex"/> is not a valid Index in <paramref name="chars"/>. </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="chars"/> does not have enough capacity from <paramref name="charIndex"/> to the End of the array to accommodate the resulting characters. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.GetMaxByteCount(System.Int32)">
            <summary>
            When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.
            </summary>
            <param name="charCount">The number of characters to encode.</param>
            <returns>
            The maximum number of bytes produced by encoding the specified number of characters.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="charCount"/> is less than zero. </exception>
            <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.GetMaxCharCount(System.Int32)">
            <summary>
            When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.
            </summary>
            <param name="byteCount">The number of bytes to decode.</param>
            <returns>
            The maximum number of characters produced by decoding the specified number of bytes.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="byteCount"/> is less than zero. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for a complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.GetByteCount(System.Char[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.
            </summary>
            <param name="chars">The character array containing the set of characters to encode.</param>
            <param name="index">The zero-based Index of the first character to encode.</param>
            <param name="count">The number of characters to encode.</param>
            <returns>
            The number of bytes produced by encoding the specified characters.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="chars"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="chars"/>. </exception>
            <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.
            </summary>
            <param name="chars">The character array containing the set of characters to encode.</param>
            <param name="charIndex">The zero-based Index of the first character to encode.</param>
            <param name="charCount">The number of characters to encode.</param>
            <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
            <param name="byteIndex">The zero-based Index at which to start writing the resulting sequence of bytes.</param>
            <returns>
            The actual number of bytes written into <paramref name="bytes"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="chars"/> is null.-or- <paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="charIndex"/> or <paramref name="charCount"/> or <paramref name="byteIndex"/> is less than zero.-or- <paramref name="charIndex"/> and <paramref name="charCount"/> do not denote a valid range in <paramref name="chars"/>.-or- <paramref name="byteIndex"/> is not a valid Index in <paramref name="bytes"/>. </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="bytes"/> does not have enough capacity from <paramref name="byteIndex"/> to the End of the array to accommodate the resulting bytes. </exception>
            <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.GetCharCount(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <param name="index">The zero-based Index of the first byte to decode.</param>
            <param name="count">The number of bytes to decode.</param>
            <returns>
            The number of characters produced by decoding the specified sequence of bytes.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="bytes"/>. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="M:Infragistics.CodePageDoubleByte.GetString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.
            </summary>
            <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
            <param name="index">The zero-based Index of the first byte to decode.</param>
            <param name="count">The number of bytes to decode.</param>
            <returns>
            A <see cref="T:System.String"/> containing the results of decoding the specified sequence of bytes.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="bytes"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="bytes"/>. </exception>
            <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation).</exception>
        </member>
        <member name="P:Infragistics.CodePageDoubleByte.CodePage">
            <summary>
            Gets the code page.
            </summary>
            <value>The code page.</value>
        </member>
        <member name="T:Infragistics.MacintoshRomanEncoding">
            <summary>
            Implementation of Macintosh Roman encoding
            </summary>
        </member>
        <member name="M:Infragistics.MacintoshRomanEncoding.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.MacintoshRomanEncoding"/> class.
            </summary>
        </member>
        <member name="T:Infragistics.Windows1251Encoding">
            <summary>
            Implementation of Windows-1252 encoding
            </summary>
        </member>
        <member name="M:Infragistics.Windows1251Encoding.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Windows1251Encoding"/> class.
            </summary>
        </member>
        <member name="T:Infragistics.Windows1252Encoding">
            <summary>
            Implementation of Windows-1252 encoding
            </summary>
        </member>
        <member name="M:Infragistics.Windows1252Encoding.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Windows1252Encoding"/> class.
            </summary>
        </member>
        <member name="T:Infragistics.Windows932Encoding">
            <summary>
            Implementation of Windows-31J (CP932) encoding
            </summary>
        </member>
        <member name="M:Infragistics.Windows932Encoding.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Windows932Encoding"/> class.
            </summary>
        </member>
        <member name="T:Infragistics.Windows936Encoding">
            <summary>
            Implementation of Code Page 936 (CP936) encoding
            </summary>
        </member>
        <member name="M:Infragistics.Windows936Encoding.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Windows936Encoding"/> class.
            </summary>
        </member>
        <member name="T:Infragistics.ZipResources">
            <summary>
            A resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="M:Infragistics.ZipResources.GetString(System.String)">
            <summary>
            Returns the resource string.
            </summary>
            <param name="resourceName">Name of the resource.</param>
            <returns></returns>
        </member>
        <member name="T:Infragistics.Compression.AddOrUpdateAction">
            <summary>
            Options for Add or Update Directory in ZipEntry
            </summary>
        </member>
        <member name="F:Infragistics.Compression.AddOrUpdateAction.AddOnly">
            <summary>
            Add entry action
            </summary>
        </member>
        <member name="F:Infragistics.Compression.AddOrUpdateAction.AddOrUpdate">
            <summary>
            Add or update entry action
            </summary>
        </member>
        <member name="F:Infragistics.Compression.BlockState.NeedMore">
            <summary>
            block not completed, Need more input or more output
            </summary>
        </member>
        <member name="F:Infragistics.Compression.BlockState.BlockDone">
            <summary>
            block flush performed
            </summary>
        </member>
        <member name="F:Infragistics.Compression.BlockState.FinishStarted">
            <summary>
            finish started, Need only more output at next deflate
            </summary>
        </member>
        <member name="F:Infragistics.Compression.BlockState.FinishDone">
            <summary>
            finish done, accept no more input or output
            </summary>
        </member>
        <member name="T:Infragistics.Compression.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.   
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream. 
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compression.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-setp between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.EncryptionAlgorithm">
             <summary>
             An enum that provides the various encryption algorithms supported by this
             library.
             </summary>
            
             <remarks>
            
             <para>
             PkzipWeak implies the use of Zip 2.0 encryption, which is known to be weak and
             subvertible.
             </para>
             
             <para>
             A note on interoperability: Values of PkzipWeak and None are specified in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
             specification</see>, and are considered to be "standard".  Zip archives produced
             using these options will be interoperable with many other zip tools and libraries,
             including Windows Explorer.
             </para>
            
             <para>
             Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
             specification, but rather imply the use of a vendor-specific extension from
             WinZip. If you want to produce interoperable Zip archives, do not use these values.
             For example, if you produce a zip archive using WinZipAes256, you will be able to
             open it in Windows Explorer on Windows XP and Vista, but you will not be able to
             extract entries; trying this will lead to an "unspecified error". For this reason,
             some people have said that a zip archive that uses WinZip's AES encryption is not
             actually a zip archive at all.  A zip archive produced this way will be readable
             with the WinZip tool (Version 11 and beyond).
             </para>
            
             <para>
             There are other third-party tools and libraries, both commercial and otherwise, that
             support WinZip's AES encryption. These will be able to Read AES-encrypted zip
             archives produced by DotNetZip, and conversely applications that use DotNetZip to
             Read zip archives will be able to Read AES-encrypted archives produced by those
             tools or libraries.  Consult the documentation for those other tools and libraries
             to find out if WinZip's AES encryption is supported.
             </para>
            
             <para>
             In case you care: According to <see href="http://www.winzip.com/aes_info.htm">the
             WinZip specification</see>, the actual AES key used is derived from the <see cref="P:Infragistics.Compression.ZipEntry.Password"/> via an algorithm that complies with <see href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration count
             of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands for
             "Password Based Key Derivation Function #2".
             </para>
            
             <para>
             A word about password strength and length: The AES encryption technology is very
             good, but any system is only as secure as the weakest link.  If you want to
             secure your data, be sure to use a password that is hard to guess.  To make it
             harder to guess (increase its "entropy"), you should make it longer.  If you use
             normal characters from an ASCII keyboard, a password of length 20 will be strong
             enough that it will be impossible to guess.  For more information on that, I'd
             encourage you to Read <see href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
             article.</see>
             </para>
            
             <para>
             The WinZip AES algorithms are not supported with the version of DotNetZip that
             runs on the .NET Compact Framework.  This is because .NET CF lacks the
             HMACSHA1 class that is required for producing the archive.
             </para>
             </remarks>
        </member>
        <member name="F:Infragistics.Compression.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.EncryptionAlgorithm.Unsupported">
            <summary>
            An encryption algorithm that is not supported by DotNetZip.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ExtractExistingFileAction">
            <summary>
            An enum for the options when extracting an entry would overwrite an existing file. 
            </summary>
            <remarks>
            <para>
            This enum describes the actions that the library can take when an
            <c>Extract()</c> or <c>ExtractWithPassword()</c> Method is called to extract an
            entry to a filesystem, and the extraction would overwrite an existing filesystem
            file.
            </para>
            </remarks>
        </member>
        <member name="F:Infragistics.Compression.ExtractExistingFileAction.Throw">
            <summary>
            Throw an exception when extraction would overwrite an existing file. (For
            COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ExtractExistingFileAction.OverwriteSilently">
            <summary>
            When extraction would overwrite an existing file, overwrite the file silently.
            The overwrite will happen even if the target file is marked as Read-only.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ExtractExistingFileAction.DontOverwrite">
            <summary>
            When extraction would overwrite an existing file, don't overwrite the file, silently. 
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ExtractExistingFileAction.InvokeExtractProgressEvent">
            <summary>
            When extraction would overwrite an existing file, invoke the ExtractProgress
            event, using an event type of <see cref="F:Infragistics.Compression.ZipProgressEventType.ExtractingExtractEntryWouldOverwrite"/>.  In
            this way, the application can decide, just-in-time, whether to overwrite the
            file. For example, a GUI application may wish to pop up a dialog to allow
            the user to choose.  (For COM clients, this is a 3.)
            </summary>
        </member>
        <member name="T:Infragistics.Compression.FlushType">
            <summary>
            Describes how to flush the current deflate operation. 
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Infragistics.Compression.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Infragistics.Compression.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This Was supposed to be removed by Zlib, but it is
            still in use in some edge cases. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.FlushType.Sync">
            <summary>
            Use this during compression to specify that all Pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.FlushType.Finish">
            <summary>Signals the End of the compression/decompression stream.</summary>
        </member>
        <member name="T:Infragistics.Compression.ZipEntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntrySource.Filesystem">
            <summary>
            The entry Was instantiated by calling AddFile() or another Method that 
            added an entry from the filesystem.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntrySource.Stream">
            <summary>
            The entry Was instantiated via <see cref="M:Infragistics.Compression.ZipEntry.#ctor(System.String,System.String,System.String)"/> or
            <see cref="M:Infragistics.Compression.ZipEntry.#ctor(System.String,System.String,System.IO.Stream)"/> .
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntrySource.Zipfile">
            <summary>
            The ZipEntry Was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ZipEntryTimestamp">
            <summary>
            An enum that specifies the type of timestamp available on the ZipEntry. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntryTimestamp.None">
            <summary>
            Default value.  
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntryTimestamp.DOS">
            <summary>
            A DOS timestamp with 2-second precision.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntryTimestamp.Windows">
            <summary>
            A Windows timestamp with 100-ns precision.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntryTimestamp.Unix">
            <summary>
            A Unix timestamp with 1-second precision.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipEntryTimestamp.InfoZip1">
            <summary>
            A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
            format is outdated and is supported for reading archives only.  
            </summary>
        </member>
        <member name="T:Infragistics.Compression.Zip64Option">
            <summary>
            Options for using ZIP64 extensions when saving zip archives. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.Zip64Option.Default">
            <summary>
            The default behavior, which is "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Infragistics.Compression.Zip64Option.Never">
            <summary>
            Do not use ZIP64 extensions when writing zip archives.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Infragistics.Compression.Zip64Option.AsNecessary">
            <summary>
            Use ZIP64 extensions when writing zip archives, as necessary. 
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole 
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Infragistics.Compression.Zip64Option.Always">
            <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ZipProgressEventType">
            <summary>
            In an EventArgs type, indicates which sort of progress event is being reported. 
            </summary>
            <remarks>
            There are events for reading, events for saving, and events for extracting. 
            </remarks>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.AddingStarted">
            <summary>
            Indicates that a Add() operation has started.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.AddingAfterAddEntry">
            <summary>
            Indicates that an individual entry in the archive has been added.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.AddingCompleted">
            <summary>
            Indicates that a Add() operation has completed.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ReadingStarted">
            <summary>
            Indicates that a Read() operation has started.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ReadingBeforeReadEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be Read.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ReadingAfterReadEntry">
            <summary>
            Indicates that an individual entry in the archive has just been Read.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ReadingCompleted">
            <summary>
            Indicates that a Read() operation has completed.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ReadingArchiveBytesRead">
            <summary>
            The given event reports the number of bytes Read so far
            during a Read() operation.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingStarted">
            <summary>
            Indicates that a Save() operation has started.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingBeforeWriteEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingAfterWriteEntry">
            <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingCompleted">
            <summary>
            Indicates that a Save() operation has completed.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingAfterSaveTempArchive">
            <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingBeforeRenameTempArchive">
            <summary>
            Indicates that the temporary file is about to be renamed to the final archive 
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingAfterRenameTempArchive">
            <summary>
            Indicates that the temporary file is has just been renamed to the final archive 
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingAfterCompileSelfExtractor">
            <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.SavingEntryBytesRead">
            <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ExtractingBeforeExtractEntry">
            <summary>
            Indicates that an entry is about to be extracted. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ExtractingAfterExtractEntry">
            <summary>
            Indicates that an entry has just been extracted. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ExtractingExtractEntryWouldOverwrite">
            <summary>
            Indicates that extraction of an entry would overwrite an existing filesystem file. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ExtractingEntryBytesWritten">
            <summary>
            The given event is reporting the number of bytes written so far for the current entry
            during an Extract() operation.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ExtractingBeforeExtractAll">
            <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZipProgressEventType.ExtractingAfterExtractAll">
            <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ReReadApprovalCallback">
            <summary>
            Delegate for the callback by which the application gives approval for multiple
            reads of the file stream. This callback is called only when the initial 
            compression operation inflates the size of the file data. 
            </summary>
        </member>
        <member name="T:Infragistics.Compression.WantCompressionCallback">
            <summary>
            Delegate for the callback by which the application tells the libraary whether
            to use compression on the file or not.  
            </summary>
            <remarks>
            <para>
            Using this callback, the application can 
            specify that previously-compressed files (.mp3, .png, .docx, etc) should 
            not be compressed, for example, or can turn on or off compression based on any 
            other factor.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipFile.WantCompression"/>
        </member>
        <member name="T:Infragistics.Compression.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save, Read, or extract operation. 
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipProgressEventArgs.CurrentEntry">
            <summary>
            The name of the Last entry saved or extracted.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract 
            operation that is in progress.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipProgressEventArgs.EventType">
            <summary>
            The type of event being reported.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipProgressEventArgs.ArchiveName">
            <summary>
            Returns the archive name associated to this event.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipProgressEventArgs.BytesTransferred">
            <summary>
            The number of bytes Read or written so far for this entry.  
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipProgressEventArgs.TotalBytesToTransfer">
            <summary>
            Total number of bytes that will be Read or written for this entry.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ReadProgressEventArgs">
            <summary>
            Provides information about the progress of a Read operation.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.AddProgressEventArgs">
            <summary>
            Provides information about the progress of a Add operation.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Infragistics.Compression.ZipEntry)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="entry">The entry involved in the event.</param>
        </member>
        <member name="P:Infragistics.Compression.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.BadPasswordException">
            <summary>
            Is raised when in ZipCrypto file there is a bad password
            with an incorrect password.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Infragistics.Compression.BadPasswordException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.BadPasswordException"/> class.
            Default ctor.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.BadPasswordException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.BadPasswordException"/> class.
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Infragistics.Compression.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.BadPasswordException"/> class. 
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">
            The message in the exception.
            </param>
            <param name="innerException">
            The innerException for this exception.
            </param>
        </member>
        <member name="T:Infragistics.Compression.BadReadException">
            <summary>
            Indicates that a Read Was attempted on a stream, and bad or incomplete data Was
            received.  
            </summary>
        </member>
        <member name="M:Infragistics.Compression.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="T:Infragistics.Compression.BadStateException">
            <summary>
            Indicates that an operation Was attempted on a ZipFile which Was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile 
            which has no filename set, you can get this exception. 
            </summary>
        </member>
        <member name="M:Infragistics.Compression.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="T:Infragistics.Compression.LogicalConjunction">
            <summary>
            Enumerates the options for a logical conjunction. This enum is intended for use 
            internally by the FileSelector class.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.FileSelector">
            <summary>
            FileSelector encapsulates logic that selects files from a source
            - a zip file or the filesystem - based on a set of criteria.  This class is used 
            internally by the DotNetZip library, but you may also find utility in using it 
            externally. 
            </summary>
            <remarks>
            <para>
            But, some applications may wish to use the FileSelector class directly, to select
            files from disk volumes based on a set of criteria, without creating or querying Zip
            archives.  The file selection criteria include: a pattern to match the filename; the
            Last modified, created, or Last accessed time of the file; the size of the file; and
            the attributes of the file.
            </para>
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.FileSelector.#ctor(System.String)">
            <summary>
            Constructor that allows the caller to specify file selection criteria.
            </summary>
            
            <remarks>
            <para>
            This constructor allows the caller to specify a set of criteria for selection of files.
            </para>
            
            <para>
            See <see cref="P:Infragistics.Compression.FileSelector.SelectionCriteria"/> for a description of the syntax of 
            the selectionCriteria string.
            </para>
            </remarks>
            
            <param name="selectionCriteria">The criteria for file selection.</param>
        </member>
        <member name="M:Infragistics.Compression.FileSelector.ToString">
            <summary>
            Returns a string representation of the FileSelector object.
            </summary>
            <returns>The string representation of the boolean logic statement of the file
            selection criteria for this instance. </returns>
        </member>
        <member name="M:Infragistics.Compression.FileSelector.SelectFiles(System.String)">
             <summary>
             Returns the names of the files in the specified directory
             that fit the selection criteria specified in the FileSelector.
             </summary>
            
             <remarks>
             This is equivalent to calling <see cref="M:Infragistics.Compression.FileSelector.SelectFiles(System.String,System.Boolean)"/> 
             with recurseDirectories = false.
             </remarks>
            
             <param name="directory">
             The name of the directory over which to apply the FileSelector criteria.
             </param>
            
             <returns>
             A collection of strings containing fully-qualified pathnames of files
             that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Infragistics.Compression.FileSelector.SelectFiles(System.String,System.Boolean)">
             <summary>
             Returns the names of the files in the specified directory that fit the selection
             criteria specified in the FileSelector, optionally recursing through subdirectories.
             </summary>
            
             <remarks>
             This Method applies the file selection criteria contained in the FileSelector to the 
             files contained in the given directory, and returns the names of files that 
             conform to the criteria. 
             </remarks>
            
             <param name="directory">
             The name of the directory over which to apply the FileSelector criteria.
             </param>
            
             <param name="recurseDirectories">
             Whether to recurse through subdirectories when applying the file selection criteria.
             </param>
            
             <returns>
             An collection of strings containing fully-qualified pathnames of files
             that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Infragistics.Compression.FileSelector.SelectEntries(Infragistics.Compression.ZipFile)">
             <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
             <remarks>
             
             <para>
             This Method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Infragistics.Compression.FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
             Method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
            
             <para>
             Normally, applications would not call this Method directly.  This Method is used 
             by the ZipFile class.
             </para>
            
             <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Infragistics.Compression.FileSelector.SelectionCriteria"/> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            
             </remarks>
            
             <param name="zip">The ZipFile from which to retrieve entries.</param>
            
             <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="M:Infragistics.Compression.FileSelector.SelectEntries(Infragistics.Compression.ZipFile,System.String)">
             <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
             <remarks>
             
             <para>
             This Method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Infragistics.Compression.FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
             Method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
            
             <para>
             Normally, applications would not call this Method directly.  This Method is used 
             by the ZipFile class.
             </para>
            
             <para>
             This overload allows the selection of ZipEntry instances from the ZipFile to be restricted 
             to entries contained within a particular directory in the ZipFile.
             </para>
            
             <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Infragistics.Compression.FileSelector.SelectionCriteria"/> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            
             </remarks>
            
             <param name="zip">The ZipFile from which to retrieve entries.</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
             
             <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="P:Infragistics.Compression.FileSelector.SelectionCriteria">
             <summary>
             The string specifying which files to include when retrieving.
             </summary>
             <remarks>
                     
             <para>
             Specify the criteria in statements of 3 elements: a noun, an operator, and a value.
             Consider the string "name != *.doc" .  The noun is "name".  The operator is "!=",
             implying "Not Equal".  The value is "*.doc".  That criterion, in English, says "all
             files with a name that does not End in the .doc extension."
             </para> 
            
             <para>
             Supported nouns include "name" for the filename; "Atime", "Mtime", and "Ctime" for
             Last access time, Last modfied time, and created time of the file, respectively;
             "attributes" for the file attributes; and "size" for the file length (uncompressed).
             The "attributes" and "name" nouns both support = and != as operators.  The "size",
             "Atime", "Mtime", and "Ctime" nouns support = and !=, and &gt;, &gt;=, &lt;, &lt;=
             as well.
             </para> 
            
             <para>
             Specify values for the file attributes as a string with one or more of the
             characters H,R,S,A,I in any order, implying Hidden, ReadOnly, System, Archive,
             and NotContextIndexed, 
             respectively.  To specify a time, use YYYY-MM-DD-HH:mm:ss as the format.  If you
             omit the HH:mm:ss portion, it is assumed to be 00:00:00 (midnight). The value for a
             size criterion is expressed in integer quantities of bytes, kilobytes (use k or kb
             after the number), megabytes (m or mb), or gigabytes (g or gb).  The value for a
             name is a pattern to match against the filename, potentially including wildcards.
             The pattern follows CMD.exe glob rules: * implies one or more of any character,
             while ? implies one character.  If the name pattern contains any slashes, it is
             matched to the entire filename, including the path; otherwise, it is matched
             against only the filename without the path.  This means a pattern of "*\*.*" Matches 
             all files one directory level deep, while a pattern of "*.*" Matches all files in 
             all directories.    
             </para> 
            
             <para>
             To specify a name pattern that includes spaces, use single quotes around the pattern.
             A pattern of "'* *.*'" will match all files that have spaces in the filename.  The full 
             criteria string for that would be "name = '* *.*'" . 
             </para> 
            
             <para>
             Some examples: a string like "attributes != H" retrieves all entries whose
             attributes do not include the Hidden bit.  A string like "Mtime &gt; 2009-01-01"
             retrieves all entries with a Last modified time after January 1st, 2009.  For
             example "size &gt; 2gb" retrieves all entries whose uncompressed size is greater
             than 2gb.
             </para> 
            
             <para>
             You can combine criteria with the conjunctions And, Or, and XOR. Using a string like
             "name = *.txt And size &gt;= 100k" for the selectionCriteria retrieves entries whose
             names End in .txt, and whose uncompressed size is greater than or equal to 100
             kilobytes.
             </para>
            
             <para>
             For more complex combinations of criteria, you can use parenthesis to group clauses
             in the boolean logic.  Absent parenthesis, the precedence of the criterion atoms is
             determined by order of appearance.  Unlike the C# language, the And conjunction does
             not take precendence over the logical Or.  This is important only in strings that
             contain 3 or more criterion atoms.  In other words, "name = *.txt and size &gt; 1000
             or attributes = H" implies "((name = *.txt And size &gt; 1000) Or attributes = H)"
             while "attributes = H Or name = *.txt and size &gt; 1000" evaluates to "((attributes
             = H Or name = *.txt) And size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
            
             <para>
             Using time properties requires some extra care. If you want to retrieve all entries
             that were Last updated on 2009 February 14, specify "Mtime &gt;= 2009-02-14 And
             Mtime &lt; 2009-02-15".  Read this to say: all files updated after 12:00am on
             February 14th, until 12:00am on February 15th.  You can use the same bracketing
             approach to specify any time period - a year, a month, a week, and so on.
             </para>
            
             <para>
             The syntax allows one special case: if you provide a string with no spaces, it is treated as
             a pattern to match for the filename.  Therefore a string like "*.xls" will be equivalent to 
             specifying "name = *.xls".  
             </para>
             
             <para>
             There is no logic in this class that insures that the inclusion criteria
             are internally consistent.  For example, it's possible to specify criteria that
             says the file must have a size of less than 100 bytes, as well as a size that
             is greater than 1000 bytes.  Obviously no file will ever satisfy such criteria,
             but this class does not Check and find such inconsistencies.
             </para>
             
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown in the setter if the value has an invalid syntax.
             </exception>
        </member>
        <member name="T:Infragistics.Compression.EnumUtil">
            <summary>
            Summary description for EnumUtil.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.EnumUtil.GetDescription(System.Enum)">
            <summary>
            Returns the value of the DescriptionAttribute if the specified Enum value has one.
            If not, returns the ToString() representation of the Enum value.
            </summary>
            <param name="value">The Enum to get the description for</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.EnumUtil.Parse(System.Type,System.String)">
            <summary>
            Converts the string representation of the name or numeric value of one or more 
            enumerated constants to an equivalent enumerated object.
            Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">A string containing the name or value to convert.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.EnumUtil.Parse(System.Type,System.String,System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more 
            enumerated constants to an equivalent enumerated object.
            A parameter specified whether the operation is case-sensitive.
            Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">A string containing the name or value to convert.</param>
            <param name="ignoreCase">Whether the operation is case-sensitive or not.</param>
            <returns></returns>
        </member>
        <member name="T:Infragistics.Compression.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.SharedUtilities.#ctor">
            private null constructor
        </member>
        <member name="M:Infragistics.Compression.SharedUtilities.TrimVolumeAndSwapSlashes(System.String)">
            <summary>
            Utility routine for transforming path names. 
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:Infragistics.Compression.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
            <summary>
            Finds a signature in the zip stream. This is useful for finding 
            the End of a zip entry, for example. 
            </summary>
            <param name="stream"></param>
            <param name="signatureToFind"></param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.SharedUtilities.ReadWithRetry(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            Workitem 7889: handle ERROR_LOCK_VIOLATION during Read
            </summary>
            <remarks>
            This could be gracefully handled with an extension attribute, but
            This assembly is built for .NET 2.0, so I cannot use them. 
            </remarks>
        </member>
        <member name="T:Infragistics.Compression.CountingStream">
            <summary> 
            A Stream wrapper, used for bookkeeping on input or output
            streams.  In some cases, it is not possible to get the Position
            of a stream, let's say, on a Write-only output stream like
            ASP.NET's Response.Output, or on a different Write-only stream
            provided as the destination for the zip by the application.
            In this case, we can use this counting stream to count the bytes
            Read or written.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
        </member>
        <member name="T:Infragistics.Compression.ZipCrypto">
            <summary> 
            This class implements the "traditional" or "classic" PKZip encryption,
            which today is considered to be weak. On the other hand it is
            ubiquitous. This class is intended for use only by the DotNetZip library.
            </summary>
            <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            ZipCrypto class.  Instead, the ZipCrypto class is instantiated and used by
            the ZipEntry() class when encryption or decryption on an entry is employed.
            If for some reason you really wanted to use a weak encryption algorithm
            in some other application, you might use this library.  But you would be much
            better off using one of the built-in strong encryption libraries in the 
            .NET Framework, like the AES algorithm or SHA. 
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.ZipCrypto.#ctor">
             <summary>
             The default constructor for ZipCrypto.
             </summary>
            
             <remarks>
             This class is intended for internal use by the library only. 
             </remarks>
                     
        </member>
        <member name="M:Infragistics.Compression.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
            <summary> 
            Call this Method on a cipher text to render the plaintext. You must
            first initialize the cipher with a call to InitCipher.
            </summary>          
            <example>
            <code>
            var cipher = new ZipCrypto();
            cipher.InitCipher(Password);
            // Decrypt the header.  This has a side effect of "further initializing the
            // encryption keys" in the traditional zip encryption. 
            byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
            </code>
            </example>
            <param name="cipherText">The encrypted buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to CipherText.Length.
            </param>
            <returns>The plaintext.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
            <summary>
            This is the converse of DecryptMessage.  It encrypts the plaintext
            and produces a ciphertext. 
            </summary>
            <param name="plaintext">The plain text buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to PlainText.Length.
            </param>
            <returns>The ciphertext.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipCrypto.InitCipher(System.String)">
             <summary>
             This initializes the cipher with the given password. 
             See AppNote.txt for details. 
             </summary>
             <param name="passphrase">The passphrase for encrypting or decrypting with this cipher.
             </param>
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:        
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
             
             Then, initialize the keys with a password:
             
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             End loop
             
             Where update_keys() is defined as:
             
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             End update_keys
             
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
             <para>
             After the keys are initialized, then you can use the cipher to encrypt
             the plaintext. 
             </para>
             <para>
             Essentially we encrypt the password with the keys, then discard the 
             ciphertext for the password. This initializes the keys for later use.
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipCrypto.MagicByte">
            <summary> 
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            End decrypt_byte
            </summary>          
        </member>
        <member name="T:Infragistics.Compression.ZipCipherStream">
            <summary>
            A Stream for reading and concurrently decrypting data from a zip file, 
            or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipCipherStream.#ctor(System.IO.Stream,Infragistics.Compression.ZipCrypto,Infragistics.Compression.CryptoMode)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="T:Infragistics.Compression.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
            by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.ReadDirEntry(Infragistics.Compression.ZipFile)">
            <summary>
            Reads one entry from the zip directory structure in the zip file. 
            </summary>
            <param name="zf">
            The zipfile for which a directory entry will be Read.  From this param, the
            Method gets the ReadStream and the expected text encoding
            (ProvisionalAlternateEncoding) which is used if the entry is not marked
            UTF-8.
            </param>
            <returns>the entry Read from the archive.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry. 
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.#ctor">
            <summary>
            Default constructor
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipEntry"/> class.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.#ctor(System.String,System.String,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipEntry"/> class.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="byteContent">Content of the byte.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipEntry"/> class.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="isDeirectory">if set to <c>true</c> [is deirectory].</param>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.#ctor(System.String,System.String,System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipEntry"/> class.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.#ctor(System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipEntry"/> class.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="stringContent">Content of the string.</param>
            <param name="encoding">The encoding.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipEntry"/> class.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="stringContent">Content of the string.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)">
             <summary>
             Sets the NTFS Creation, Access, and Modified times for the given entry.
             </summary>
            
             <remarks>
             <para>
             When adding an entry from a file or directory, the Creation, Access, and
             Modified times for the given entry are automatically set from the filesystem
             values. When adding an entry from a stream or string, the values are
             implicitly set to DateTime.Now.  The application may wish to set these
             values to some arbitrary value, before saving the archive.  If you set the
             times using this Method, the <see cref="P:Infragistics.Compression.ZipEntry.LastModified"/> property also gets
             set, to the same value provided for ModifiedTime.
             </para>
            
             <para>
             The values you set here will be retrievable with the <see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>,
             <see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/> and <see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/> Read-only properties.
             </para>
            
             <para>
             When this Method is called, the <see cref="P:Infragistics.Compression.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> flag is automatically set.
             </para>
            
             <para>
             DateTime values provided here without a DateTimeKind are assumed to be Local Time.
             </para>
             </remarks>
             <param name="created">the creation time of the entry.</param>
             <param name="accessed">the Last access time of the entry.</param>
             <param name="modified">the Last modified time of the entry.</param>
            
             <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateDirectory(System.String)">
            <summary>
            Creates the directory.
            </summary>
            <param name="directoryname">The directoryname.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateDirectory(System.String,System.String)">
            <summary>
            Creates the directory.
            </summary>
            <param name="directoryname">The directoryname.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateFile(System.String)">
            <summary>
            Creates the ZipEntry instance, that represents a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateFile(System.String,System.String)">
            <summary>
            Creates the ZipEntry instance, that represents a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateFile(System.String,System.String,System.IO.Stream)">
            <summary>
            Creates the ZipEntry instance, that represents a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="stream">The stream.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateFile(System.String,System.String,System.Byte[])">
            <summary>
            Creates the ZipEntry instance, that represents a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="byteContent">Content of the byte.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateFile(System.String,System.String,System.String)">
            <summary>
            Creates the ZipEntry instance, that represents a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="stringContent">Content of the string.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CreateFile(System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Creates the ZipEntry instance, that represents a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="directoryPathInArchive">The directory path in archive.</param>
            <param name="stringContent">Content of the string.</param>
            <param name="encoding">Used encoding</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.OpenReader">
             <summary>
             Opens the backing stream for the zip entry in the archive, for reading. 
             </summary>
             
             <remarks>
            
             <para>
             Compression library offers a variety of ways to extract entries from a zip file.
             This Method allows an application to extract and entry by reading a Stream. 
             </para>
            
             <para>
             The return value is a <see cref="T:Infragistics.Compression.CrcCalculatorStream"/>.  Use it
             as you would any stream for reading.  The data you get by calling <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> on that stream will be decrypted and
             decompressed.
             </para>
             
             <para>
             CrcCalculatorStream adds one additional feature: it keeps a CRC32 checksum
             on the bytes of the stream as it is Read.  The CRC value is available in the
             <see cref="P:Infragistics.Compression.CrcCalculatorStream.Crc32"/> property on the
             <c>CrcCalculatorStream</c>.  When the Read is complete, this CRC
             <em>should</em> be checked against the <see cref="P:Infragistics.Compression.ZipEntry.Crc32"/> property
             on the <c>ZipEntry</c> to validate the content of the ZipEntry.  You don't
             have to validate the entry using the CRC, but you should. Check the example
             for how to do this.
             </para>
             
             <para>
             If the entry is protected with a password, then you Need to provide a
             password prior to calling <see cref="M:Infragistics.Compression.ZipEntry.OpenReader"/>, either by setting the
             <see cref="P:Infragistics.Compression.ZipEntry.Password"/> property on the entry, or the <see cref="P:Infragistics.Compression.ZipFile.Password"/> property on the <c>ZipFile</c> itself. Or, you can
             use <see cref="M:Infragistics.Compression.ZipEntry.OpenReader(System.String)"/>, the overload of OpenReader that
             accepts a password parameter.
             </para>
             
             </remarks>
             
             <example>
             This example shows how to open a zip archive, then Read in a named entry via
             a stream.  After the Read loop is complete, the code compares the calculated
             during the Read loop with the expected CRC on the <c>ZipEntry</c>, to verify
             the extraction.
             <code>
             using (ZipFile zip = new ZipFile(StreamToRead))
             {
               ZipEntry e1= zip["Elevation.mp3"];
               using (CrcCalculatorStream s = e1.OpenReader())
               {
                 byte[] buffer = new byte[4096];
                 int n, totalBytesRead= 0;
                 do {
                   n = s.Read(buffer,0, buffer.Length);
                   totalBytesRead+=n; 
                 } while (n&gt;0);
                  if (s.Crc32 != e1.Crc32)
                   throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                  if (totalBytesRead != e1.UncompressedSize)
                   throw new Exception(string.Format("We Read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
               }
             }
             </code>
             <code lang="VB">
               Using zip As New ZipFile(StreamToRead)
                   Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
                   Using s As CrcCalculatorStream = e1.OpenReader
                       Dim n As Integer
                       Dim buffer As Byte() = New Byte(4096) {}
                       Dim totalBytesRead As Integer = 0
                       Do
                           n = s.Read(buffer, 0, buffer.Length)
                           totalBytesRead = (totalBytesRead + n)
                       Loop While (n &gt; 0)
                       If (s.Crc32 &lt;&gt; e1.Crc32) Then
                           Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                       End If
                       If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                           Throw New Exception(String.Format("We Read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                       End If
                   End Using
               End Using
             </code>
             </example>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.OpenReader(System.String)">
            <summary>
            Opens the backing stream for an encrypted zip entry in the archive, for reading. 
            </summary>
            
            <remarks>
            <para>
            See the documentation on the <see cref="M:Infragistics.Compression.ZipEntry.OpenReader"/> Method for full
            details.  This overload allows the application to specify a password for the
            <c>ZipEntry</c> to be Read.
            </para>
            </remarks>
            
            <param name="password">The password to use for decrypting the entry.</param>
            <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.CopyMetaData(Infragistics.Compression.ZipEntry)">
            <summary>
            Copy metadata that may have been changed by the app.  We do this when
            resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
            tries to party on that file some more, we may Need to Reset() it , which
            means re-reading the entries and then copying the metadata.  I think.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipEntry.PrepSourceStream">
             <summary>
             Stores the position of the entry source stream, or, if the position is
             already stored, seeks to that position.
             </summary>
            
             <remarks>
             This Method is called in prep for reading the source stream.  If PKZIP
             encryption is used, then we Need to calc the CRC32 before doing the
             encryption.  Hence we Need to be able to seek backward in the source when
             saving the ZipEntry. This Method is called from the place which calculates
             the CRC, and also from the Method that does the encryption of the file data.
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.AttributesIndicateDirectory">
            <summary>
            True if the referenced entry is a directory.  
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.ActualEncoding">
             <summary>
             The text encoding actually used for this ZipEntry.
             </summary>
            
             <remarks>
            
             <para> This Read-only property describes the encoding used by the
             <c>ZipEntry</c>.  If the entry has been Read in from an existing ZipFile, then
             it may take the value UTF-8, if the entry is coded to specify UTF-8.  If the
             entry does not specify UTF-8, the typical case, then the encoding used is
             whatever the application specified in the call to <c>ZipFile.Read()</c>. If the
             application has used one of the overloads of <c>ZipFile()</c> ctor that does not
             accept an encoding parameter, then the encoding used is UTF8.  </para>
            
             <para> If the entry is being created, then the value of ActualEncoding is taken
             according to the logic described in the documentation for <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/>.  </para>
            
             <para> An application might be interested in retrieving this property to see if
             an entry Read in from a file has used Unicode (UTF-8).  </para>
            
             </remarks>
            
             <seealso cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.IsText">
             <summary>
             Indicates whether an entry is mark as a text file.
             </summary>
             <remarks>
            
             <para>
             The ZIP format includes a provision for specifying whether an entry in the
             zip archive is a text or binary file.  Such a distinction may seem irrelevant
             now, but some zip tools or libraries, in particular older PKUnzip on IBM
             mainframes, require this bit to be set in order to unzip text and binary
             files properly.  Set this property to true to set the Text bit for an entry
             that represents a text file, if you want your zip files to be readable by
             these older zip tools and libraries.
             </para>
            
             <para>
             When writing a zip file, you must set the property before calling
             <c>Save()</c> on the Stream.
             </para>
            
             <para>
             If you are not having compatibility problems with zip archives, you can
             safely ignore this property.
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.LastModified">
             <summary>
             The time and date at which the file indicated by the <c>ZipEntry</c> Was Last modified. 
             </summary>
             
             <remarks>
             <para>
             The DotNetZip library sets the LastModified value for an entry, equal to the
             Last Modified time of the file in the filesystem.  If an entry is added from
             a stream, in which case no Last Modified attribute is available, the library
             uses <c>System.DateTime.Now</c> for this value, for the given entry.
             </para>
            
             <para>
             This property allows the application to retrieve and possibly set the
             LastModified value on an entry, to an arbitrary value.  <see cref="T:System.DateTime"/> values with a <see cref="T:System.DateTimeKind"/>
             setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
             <c>DateTimeKind.Local</c>.
             </para>
            
             <para>
             Be aware that because of the way the PKZip specification describes how times
             are stored in the zip file, the full precision of the <c>System.DateTime</c>
             datatype is not stored for the Last modified time when saving zip files.
             For more information on how times are formatted, see the PKZip
             specification.
             </para>
            
             <para>
             .NET gives a value which is more intuitively correct, but is also
             potentially incorrect, and which is not invertible. Win32 gives a value
             which is intuitively incorrect, but is strictly correct.
             </para>
             <para>
             Because of this funkiness, this library adds one hour to the LastModified
             time on the extracted file, if necessary.  That is to say, if the time in
             question had occurred in what the .NET Base Class Library assumed to be
             DST. This assumption may be wrong given the constantly changing DST
             rules, but it is the best we can do.
             </para>
             </remarks>
            
        </member>
        <!-- Badly formed XML comment ignored for member "P:Infragistics.Compression.ZipEntry.ModifiedTime" -->
        <member name="P:Infragistics.Compression.ZipEntry.AccessTime">
            <summary>
            Last Access time for the file represented by the entry.
            </summary>
            <remarks>
            This value may or may not be meaningful.  If the <c>ZipEntry</c> Was Read from an existing
            Zip archive, this information may not be available. For an explanation of why, see
            <see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.CreationTime">
             <summary>
             The file creation time for the file represented by the entry.
             </summary>
            
             <remarks> This value may or may not be meaningful.  If the <c>ZipEntry</c> Was Read
             from an existing zip archive, and the creation time Was not set on the entry
             when the zip file Was created, then this property may be meaningless. For an
             explanation of why, see <see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>.  </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.EmitTimesInWindowsFormatWhenSaving">
             <summary>
             Specifies whether the Creation, Access, and Modified times for the
             given entry will be emitted in "Windows format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
             An application creating a zip archive can use this flag to explicitly
             specify that the file times for the entry should or should not be stored in
             the zip archive in the format used by Windows. The default value of this
             property is <c>true</c>.
             </para>
            
             <para>
             When adding an entry from a file or directory, the Creation (<see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>), Access (<see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>), and Modified (<see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>) times for the given entry are automatically set from the
             filesystem values. When adding an entry from a stream or string, all three
             values are implicitly set to DateTime.Now.
             </para>
            
             <para>
             <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
             zip specification</see> describes multiple ways to format these times in a
             zip file. One is the format Windows applications normally use: 100ns ticks
             since Jan 1, 1601 UTC.  The other is a format Unix applications typically
             use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an "extra
             field" in the zip entry when saving the zip archive. The former uses an
             extra field with a Header Id of 0x000A, while the latter uses a header ID of
             0x5455.
             </para>
            
             <para>
             Not all tools and libraries can interpret these fields.  Windows compressed
             folders is one that can Read the Windows Format timestamps, while I believe
             the <see href="http://www.info-zip.org/">Infozip</see> tools can Read the Unix
             format timestamps. Some tools and libraries may be able to Read only one or
             the other.
             </para>
            
             <para>
             The times stored are taken from <see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>, <see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>, and <see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
             This property is not mutually exclusive from the <see cref="P:Infragistics.Compression.ZipFile.EmitTimesInUnixFormatWhenSaving"/> property.
             It is possible that a zip entry can embed the timestamps in both
             forms.
             </para>
            
             <para>
             Normally you will use the <see cref="P:Infragistics.Compression.ZipFile.EmitTimesInWindowsFormatWhenSaving"/> property, to specify the
             behavior for all entries in a zip, rather than the property on each
             individual entry.
             </para>
            
             </remarks>
            
             <seealso cref="M:Infragistics.Compression.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.EmitTimesInUnixFormatWhenSaving">
             <summary>
             Specifies whether the Creation, Access, and Modified times for the given
             entry will be emitted in "Unix(tm) format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
             An application creating a zip archive can use this flag to explicitly
             specify that the file times for the entry should or should not be stored in
             the zip archive in the format used by Unix. By default this flag is
             <c>false</c>.
             </para>
            
             <para>
             When adding an entry from a file or directory, the Creation (<see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>), Access (<see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>), and Modified (<see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>) times for the given entry are automatically set from the
             filesystem values. When adding an entry from a stream or string, all three
             values are implicitly set to DateTime.Now.
             </para>
            
             <para>
             <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
             zip specification</see> describes multiple ways to format these times in a
             zip file. One is the format Windows applications normally use: 100ns ticks
             since Jan 1, 1601 UTC.  The other is a format Unix applications typically
             use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an "extra
             field" in the zip entry when saving the zip archive. The former uses an
             extra field with a Header Id of 0x000A, while the latter uses a header ID of
             0x5455.
             </para>
            
             <para>
             Not all tools and libraries can interpret these fields.  Windows compressed
             folders is one that can Read the Windows Format timestamps, while I believe
             the <see href="http://www.info-zip.org/">Infozip</see> tools can Read the Unix
             format timestamps. Some tools and libraries may be able to Read only one or
             the other.
             </para>
            
             <para>
             The times stored are taken from <see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>, <see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>, and <see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
             This property is not mutually exclusive from the <see cref="P:Infragistics.Compression.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> flag.  It is possible that a
             zip entry can embed the timestamps in both forms.
             </para>
            
             <para>
             Normally you will use the <see cref="P:Infragistics.Compression.ZipFile.EmitTimesInUnixFormatWhenSaving"/> property, to specify the
             behavior for all entries, rather than the property on each individual entry.
             </para>
             </remarks>
            
             <seealso cref="M:Infragistics.Compression.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Infragistics.Compression.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.Timestamp">
             <summary>
             The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
             This property is valid only for a ZipEntry that Was Read from a zip archive.
             It indicates the type of timestamp attached to the entry. 
             </remarks>
            
             <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.Attributes">
             <summary>
             The file attributes for the entry.
             </summary>
             <remarks>
            
             <para>
             The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
             ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
             <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
             adding an entry from the filesystem.  When adding an entry from a stream or
             string, the Attributes are not set.
             </para>
            
             <para>
             When reading a <c>ZipEntry</c> from a ZipFile, the attributes are set
             according to the data stored in the ZipFile. If you extract the entry from
             the archive to a disk file, DotNetZip will set the attributes on the
             resulting file accordingly.
             </para>
            
             <para>
             The attributes can be set explicitly by the application for whatever
             purpose.  For example the application may wish to set the
             FileAttributes.ReadOnly bit for all entries added to an archive, so that on
             unpack, this attribute will be set on the extracted file.  Any changes you
             make to this property are made permanent only when you call a Save() Method
             on the <c>ZipFile</c> instance that contains the ZipEntry.
             </para>
            
             <para>
             For example, an application may wish to zip up a directory and set the
             ReadOnly bit on every file in the archive, so that upon later extraction,
             the resulting files will be marked as ReadOnly.  Not every extraction tool
             respects these attributes, but if you unpack with DotNetZip, then the
             attributes will be set as they are stored in the ZipFile.
             </para>
            
             <para>
             These attributes may not be interesting or useful if the resulting archive
             is extracted on a non-Windows platform.  How these attributes get used upon
             extraction depends on the platform and tool used.
             </para>
            
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.ForceNoCompression">
             <summary>
             Disables compression for the entry when calling ZipFile.Save(Stram).
             </summary>
            
             <remarks>
             <para>
             By default, the library compresses entries when saving them to archives. 
             When this property is set to true, the entry is not compressed when written to 
             the archive.  For example, the application might want to set flag to <c>true</c>
             this when zipping up JPG or MP3 files, which are already compressed.  The application
             may also want to turn off compression for other reasons.
             </para>
            
             <para> When updating a ZipFile, you may not turn off compression on an entry
             that has been encrypted.  In other words, if you Read an existing <c>ZipFile</c> with
             one of the <c>ZipFile(Stream)</c> overrides, and then change the
             <c>CompressionMethod</c> on an entry that has <c>Encryption</c> not equal to
             <c>None</c>, you will receive an exception.  There is no way to modify the
             compression on an encrypted entry, without extracting it and re-adding it into
             the ZipFile.  </para> </remarks>
            
             <seealso cref="P:Infragistics.Compression.ZipFile.ForceNoCompression"/>
             <seealso cref="P:Infragistics.Compression.ZipEntry.CompressionMethod"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.FileName">
             <summary>
             The name of the file contained in the ZipEntry. 
             </summary>
             
             <remarks>
            
             <para> This is the name of the entry in the <c>ZipFile</c> itself.  When creating or
             updating a zip file, this name may be different than the name of the filesystem
             file used to create the entry (LocalFileName). In fact, there may be no
             filesystem file at all, if the entry is created from a stream or a string.  When
             reading a zip file, this property takes the value of the entry name as stored in
             the zip file. If you extract such an entry, the extracted file will take the name
             given by this property.</para>
            
             <para> When setting this property, the value is made permanent only after a call
             to one of the <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains
             the ZipEntry. By reading in a <c>ZipFile</c>, then explicitly setting the
             FileName on an entry contained within the <c>ZipFile</c>, and then calling
             <c>Save()</c>, you will effectively rename the entry within the zip archive.
             </para>
            
             <para> When writing a zip, this value written to the zip file replaces
             backslashes with forward slashes, according to <see
             href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification</see>, for compatibility with Unix(tm) and ... get this.... Amiga!
             </para>
            
             </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Infragistics.Compression.ZipEntry.InputStream" -->
        <member name="P:Infragistics.Compression.ZipEntry.InputStreamWasJitProvided">
             <summary>
             A flag indicating whether the InputStream Was provided Just-in-time.
             </summary>
             <remarks>
             
             <para>
             When creating a zip archive, an application can obtain content for one or more of the
             <c>ZipEntry</c> instances from streams, using the <see cref="M:Infragistics.Compression.ZipFile.#ctor(System.IO.Stream)"/> Method.  At the
             time of calling that Method, the application can supply null as the value of the
             stream parameter.  By doing so, the application indicates to the library that it will
             provide a stream for the entry on a just-in-time basis, at the time one of the
             <c>ZipFile.Save()</c> methods is called and the data for the various entries are being
             compressed and written out.
             </para>
            
             <para>
             In this case, the application can set the <see cref="P:Infragistics.Compression.ZipEntry.InputStream"/> property,
             typically within the SaveProgress event (event type: <see cref="F:Infragistics.Compression.ZipProgressEventType.SavingBeforeWriteEntry"/>) for that entry.  
             </para>
            
             <para>
             The application will later want to call Close() and Dispose() on that stream.  In the
             SaveProgress event, when the event type is <see cref="F:Infragistics.Compression.ZipProgressEventType.SavingAfterWriteEntry"/>, the application can do so.  This
             flag indicates that the stream has been provided by the application on a just-in-time
             basis and that it is the application's responsibility to call Close/Dispose on that
             stream.
             </para>
            
             </remarks>
             <seealso cref="P:Infragistics.Compression.ZipEntry.InputStream"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.Source">
            <summary>
            An enum indicating the source of the ZipEntry.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.VersionNeeded">
             <summary>
             The version of the zip engine needed to Read the ZipEntry.  
             </summary>
             
             <remarks>
             <para>
             This is a readonly property, indicating the version of <a
             href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification</a> that the extracting tool or library must support to
             extract the given entry.  Generally higher versions indicate newer features.
             Older zip engines obviously won't know about new features, and won't be able
             to extract entries that depend on those newer features.
             </para>
             
             <list type="TABLE">
             <listheader>
             <term>value</term>
             <description>Features</description>
             </listheader>
             
             <item>
             <term>20</term>
             <description>a basic Zip Entry, potentially using PKZIP encryption. 
             </description>
             </item>
             
             <item>
             <term>45</term>
             <description>The ZIP64 extension is used on the entry.
             </description>
             </item>
             
             <item>
             <term>46</term>
             <description> File is compressed using BZIP2 compression*</description>
             </item>
            
             <item>
             <term>50</term>
             <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
             </item>
            
             <item>
             <term>51</term>
             <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
             </item>
            
             <item>
             <term>52</term>
             <description> File is encrypted using corrected RC2-64 encryption**</description>
             </item>
            
             <item>
             <term>61</term>
             <description> File is encrypted using non-OAEP key wrapping***</description>
             </item>
            
             <item>
             <term>63</term>
             <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
             </item>
            
             </list>
            
             <para>
             There are other values possible, not listed here. DotNetZip supports regular
             PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract entries
             that require a zip engine higher than 45.
             </para>
            
             <para>
             This value is set upon reading an existing zip file, or after saving a zip
             archive.
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.Comment">
             <summary>
             The comment attached to the ZipEntry. 
             </summary>
            
             <remarks>
             <para>
             Each entry in a zip file can optionally have a comment associated to it. The
             comment might be displayed by a zip tool during extraction, for example. 
             </para>
            
             <para>
             By default, the <c>Comment</c> is encoded in UTF8 code page. You can specify 
             an alternative with <see cref="P:Infragistics.Compression.ZipEntry.ProvisionalAlternateEncoding"/>
             </para>
             </remarks>
             <seealso cref="P:Infragistics.Compression.ZipEntry.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.RequiresZip64">
             <summary>
             Indicates whether the entry requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para> This property is null (Nothing in VB) until a <c>Save()</c> Method on the
             containing <see cref="T:Infragistics.Compression.ZipFile"/> instance has been called. The property is
             non-null (<c>HasValue</c> is true) only after a <c>Save()</c> Method has been called.
             </para>
            
             <para> After the containing <c>ZipFile</c> has been saved, the Value of this
             property is true if any of the following three conditions holds: the
             uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed size of
             the entry is larger than 0xFFFFFFFF; the relative offset of the entry within the
             zip archive is larger than 0xFFFFFFFF.  These quantities are not known until a
             <c>Save()</c> is attempted on the zip archive and the compression is applied.
             </para>
            
             <para>If none of the three conditions holds, then the <c>Value</c> is false.</para>
            
             <para> A <c>Value</c> of false does not indicate that the entry, as saved in the
             zip archive, does not use ZIP64.  It merely indicates that ZIP64 is <em>not
             required</em>.  An entry may use ZIP64 even when not required if the <see cref="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving"/> property on the containing <c>ZipFile</c> instance
             is set to <see cref="F:Infragistics.Compression.Zip64Option.Always"/>, or if the <see cref="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving"/> property on the containing <c>ZipFile</c>
             instance is set to <see cref="F:Infragistics.Compression.Zip64Option.AsNecessary"/> and the output stream
             Was not seekable.  </para>
            
             </remarks>
             <seealso cref="P:Infragistics.Compression.ZipEntry.OutputUsedZip64"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.OutputUsedZip64">
             <summary>
             Indicates whether the entry actually used ZIP64 extensions, as it Was most recently 
             written to the output file or stream.
             </summary>
            
             <remarks>
            
             <para> This Nullable property is null (Nothing in VB) until a <c>Save()</c>
             Method on the containing <see cref="T:Infragistics.Compression.ZipFile"/> instance has been
             called. <c>HasValue</c> is true only after a <c>Save()</c> Method has been
             called.  </para>
            
             <para>
             The value of this property for a particular <c>ZipEntry</c> may change over successive calls to
             <c>Save()</c> methods on the containing ZipFile, even if the file that corresponds to the <c>ZipEntry</c> does
             not. This may happen if other entries contained in the <c>ZipFile</c> expand, causing the offset 
             for this particular entry to exceed 0xFFFFFFFF. 
             </para>
             </remarks>
             <seealso cref="P:Infragistics.Compression.ZipEntry.RequiresZip64"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.BitField">
             <summary>
             The bitfield for the entry as defined in the zip spec. You probably never Need to look at this.
             </summary>
            
             <remarks>
             <list type="TABLE">
             <listheader>
             <term>bit</term>
             <description>meaning</description>
             </listheader>
             
             <item>
             <term>0</term>
             <description>set if encryption is used.</description>
             </item>
             
             <item>
             <term>1-2</term>
             <description>
             set to determine whether normal, max, fast deflation.  Compression library
             always leaves these bits unset when writing (indicating "normal"
             deflation"), but can Read an entry with any value here.
             </description>
             </item>
             
             <item>
             <term>3</term>
             <description>
             Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
             local header.  This bit gets set on an entry during writing a zip file, when
             it is saved to a non-seekable output stream.
             </description>
             </item>
             
            
             <item>
             <term>4</term>
             <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
             </item>
             
             <item>
             <term>5</term>
             <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
             </item>
             
             <item>
             <term>6</term>
             <description>
             set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
             set). This bit is not set if WinZip's AES encryption is set.</description>
             </item>
             
             <item>
             <term>7</term>
             <description>not used</description>
             </item>
             
             <item>
             <term>8</term>
             <description>not used</description>
             </item>
             
             <item>
             <term>9</term>
             <description>not used</description>
             </item>
             
             <item>
             <term>10</term>
             <description>not used</description>
             </item>
             
             <item>
             <term>11</term>
             <description>
             Language encoding flag (EFS).  If this bit is set, the filename and comment
             fields for this file must be encoded using UTF-8. This library currently
             does not support UTF-8.
             </description>
             </item>
             
             <item>
             <term>12</term>
             <description>Reserved by PKWARE for enhanced compression.</description>
             </item>
             
             <item>
             <term>13</term>
             <description>
             Used when encrypting the Central Directory to indicate selected data values
             in the Local Header are masked to hide their actual values.  See the section
             in <a href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification</a> describing the Strong Encryption Specification for
             details.
             </description>
             </item>
                     
             <item>
             <term>14</term>
             <description>Reserved by PKWARE.</description>
             </item>
             
             <item>
             <term>15</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.CompressionMethod">
             <summary>
             The compression Method employed for this ZipEntry. 
             </summary>
             
             <remarks>
            
             <para> <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
             Zip specification</see> allows a variety of compression methods.  This library
             supports just two: 0x08 = Deflate.  0x00 = Store (no compression).  </para>
             
             <para>
             When reading an entry from an existing zipfile, the value you retrieve here
             indicates the compression Method used on the entry by the original creator of the zip.  
             When writing a zipfile, you can specify either 0x08 (Deflate) or 0x00 (None).  If you 
             try setting something else, you will get an exception.  
             </para>
             
             <para> You may wish to set <c>CompressionMethod</c> to 0 (None) when zipping
             previously compressed data like a jpg, png, or mp3 file.  This can save time and
             cpu cycles.  Setting <c>CompressionMethod</c> to 0 is equivalent to setting
             <c>ForceNoCompression</c> to <c>true</c>.  </para>
             
             <para> When updating a <c>ZipFile</c>, you may not modify the
             <c>CompressionMethod</c> on an entry that has been encrypted.  In other words,
             if you Read an existing <c>ZipFile</c> with one of the <c>ZipFile(Stream)</c>
             methods, and then change the <c>CompressionMethod</c> on an entry that has
             <c>Encryption</c> not equal to <c>None</c>, you will receive an exception.
             There is no way to modify the compression on an encrypted entry, without
             extracting it and re-adding it into the <c>ZipFile</c>.  </para>
            
             </remarks>
             
             <example>
             In this example, the first entry added to the zip archive uses 
             the default behavior - compression is used where it makes sense.  
             The second entry, the MP3 file, is added to the archive without being compressed.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               MemoryStream stream = new MemoryStream();
               ZipEntry e1= ZipEntry.CreateFile(@"notes\Readme.txt");
               zip.Entries.Add(e1);
               ZipEntry e2= ZipEntry.CreateFile(@"music\StopThisTrain.mp3"); 
               e2.CompressionMethod = 0;
               zip.Entries.Add(e2);
               zip.Save(stream);
             }
             </code>
             
             <code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               Dim stream as New MemoryStream
               Dim e1 as ZipEntry = ZipEntry.CreateFile(@"notes\Readme.txt")
               zip.Entries.Add(e1)
               Dim e2 as ZipEntry = ZipEntry.CreateFile(@"music\StopThisTrain.mp3")
               e2.CompressionMethod = 0
               zip.Entries.Add(e2)
               zip.Save(stream)
             End Using
             </code>
             </example>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.CompressedSize">
             <summary>
             The compressed size of the file, in bytes, within the zip archive. 
             </summary>
            
             <remarks> The compressed size is computed during compression. The value is valid
             AFTER reading in an existing zip file, or AFTER saving a zipfile you are
             creating.  </remarks>
            
             <seealso cref="P:Infragistics.Compression.ZipEntry.UncompressedSize"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.UncompressedSize">
            <summary>
            The size of the file, in bytes, before compression, or after extraction. 
            </summary>
            <remarks>
            This property is valid AFTER reading in an existing zip file, or AFTER saving the 
            <c>ZipFile</c> that contains the ZipEntry.
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipEntry.CompressedSize"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.CompressionRatio">
             <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
             
             <remarks>
             <para>
             This is a ratio of the compressed size to the uncompressed size of the entry,
             expressed as a double in the range of 0 to 100+. A value of 100 indicates no
             compression at all.  It could be higher than 100 when the compression algorithm
             actually inflates the data, as may occur for small files, or uncompressible
             data that is encrypted.
             </para>
            
             <para>
             You could format it for presentation to a user via a format string of "{3,5:F0}%"
             to see it as a percentage. 
             </para>
            
             <para>
             If the size of the original uncompressed file is 0, (indicating a denominator of 0)
             the return value will be zero. 
             </para>
            
             <para>
             This property is valid AFTER reading in an existing zip file, or AFTER saving the 
             <c>ZipFile</c> that contains the ZipEntry. You cannot know the effect of a compression 
             transform until you try it. 
             </para>
            
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.Crc32">
             <summary>
             The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry. 
             </summary>
             
             <remarks>
            
             <para> You probably don't Need to concern yourself with this. It is used
             internally by Compression library to verify files or streams upon extraction.  
             </para>
            
             <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
             CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
             PNG, MPEG-2, and other protocols and formats.  It is a Read-only property; when
             creating a Zip archive, the CRC for each entry is set only after a call to
             Save(Stream) on the containing ZipFile. When reading an existing zip file, the value
             of this property reflects the stored CRC for the entry.  </para>
            
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file). 
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.UsesEncryption">
             <summary>
             A derived property that is <c>true</c> if the entry uses encryption.  
             </summary>
            
             <remarks>
             <para>
             This is a readonly property on the entry.  When reading a zip file, the
             value for the <c>ZipEntry</c> is determined by the data Read from the zip
             file.  After saving a ZipFile, the value of this property for each
             <c>ZipEntry</c> indicates whether encryption Was actually used (which will
             have been true if the <see cref="P:Infragistics.Compression.ZipEntry.Password"/> Was set and the <see cref="P:Infragistics.Compression.ZipEntry.Encryption"/> property Was something other than <see cref="F:Infragistics.Compression.EncryptionAlgorithm.None"/>.
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.Encryption">
             <summary>
             Set this to specify which encryption algorithm to use for the entry
             when saving it to a zip archive.
             </summary>
             
             <remarks>
            
             <para>
             Set this property in order to encrypt the entry when the <c>ZipFile</c> is
             saved. When setting this property, you must also set a <see cref="P:Infragistics.Compression.ZipEntry.Password"/> on the entry.  If you set a value other than <see cref="F:Infragistics.Compression.EncryptionAlgorithm.None"/> on this property and do not set a
             <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
             data is encrypted as the <c>ZipFile</c> is saved, when you call <see cref="M:Infragistics.Compression.ZipFile.Save(System.IO.Stream)"/> or one of its cousins on the containing
             <c>ZipFile</c> instance. You do not Need to specify the <c>Encryption</c>
             when extracting entries from an archive.
             </para>
            
             <para>
             The Zip specification from PKWare defines a set of encryption algorithms,
             and the data formats for the zip archive that support them, and PKWare
             supports those algorithms in the tools it produces. Other vendors of tools
             and libraries, such as WinZip or Xceed, typically support <em>a subset</em>
             of the algorithms specified by PKWare. These tools can sometimes support
             additional different encryption algorithms and data formats, not specified
             by PKWare. The AES Encryption specified and supported by WinZip is the most
             popular example. This library supports a subset of the complete set of
             algorithms specified by PKWare and other vendors.  
             </para>
            
             <para>
             There is no common, ubiquitous multi-vendor standard for strong encryption
             within zip files. There is broad support for so-called "traditional" Zip
             encryption, sometimes called Zip 2.0 encryption, as <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
             by PKWare</see>, but this encryption is considered weak and
             breakable. This library currently supports the Zip 2.0 "weak" encryption,
             and also a stronger WinZip-compatible AES encryption, using either 128-bit
             or 256-bit key strength. If you want DotNetZip to support an algorithm
             that is not currently supported, call the author of this library and maybe
             we can talk business.
             </para>
            
             <para>
             The <see cref="T:Infragistics.Compression.ZipFile"/> class also has a <see cref="P:Infragistics.Compression.ZipFile.Encryption"/>
             property.  In most cases you will use <em>that</em> property when setting
             encryption. This property takes precedence over any <c>Encryption</c> set on the
             <c>ZipFile</c> itself.  Typically, you would use the per-entry Encryption when
             most entries in the zip archive use one encryption algorithm, and a few entries
             use a different one.  If all entries in the zip file use the same Encryption,
             then it is simpler to just set this property on the ZipFile itself, when
             creating a zip archive.
             </para>
            
             <para>
             Some comments on updating archives: If you Read a <c>ZipFile</c>, you cannot
             modify the Encryption on any encrypted entry, except by extracting the entry
             using  the original password (if any), removing the original entry via <see cref="P:Infragistics.Compression.ZipFile.Entries"/>, and then adding a new entry with a
             new Password and Encryption.
             </para>
            
             <para>
             For example, suppose you Read a <c>ZipFile</c>, and there is an entry encrypted
             with PKZip 2.0 encryption.  Setting the <c>Encryption</c> property on that
             <c>ZipEntry</c> to different encryption will cause an
             exception to be thrown.  Setting the <c>Encryption</c> on the <c>ZipFile</c> and
             then adding new entries will allow that encryption to be used on the newly added
             entries.  During the <c>Save()</c>, the existing entries are copied through to
             the new zip archive, in their original encrypted form (encrypted or not), while
             the newly-added entries are encrypted as usual.
             </para>
            
             <para>
             The WinZip AES encryption algorithms are not supported on the .NET Compact
             Framework.
             </para>
             </remarks>
            
             <example>
             <para>
             This example creates a zip archive that uses encryption, and then extracts entries
             from the archive.  When creating the zip archive, the ReadMe.txt file is zipped
             without using a password or encryption.  The other file uses encryption.  
             </para>
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 MemoryStream stream = new MemoryStream();
                 ZipEntry e1 = ZipEntry.CreateFile("ReadMe.txt");
                 zip.Entries.Add(e1);
                 ZipEntry e2= ZipEntry.CreateFile("2008-Regional-Sales-Report.pdf");
                 e2.Encryption= EncryptionAlgorithm.WinZipAes256;
                 e2.Password= "Top.Secret.No.Peeking!";
                 zip.Entries.Add(e2);
                 zip.Save(stream);
             }
             
             // Extract a zip archive that uses AES Encryption.
             // You do not Need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read(stream, "Top.Secret.No.Peeking!"))
             {
                 // Specify the password that is used during extraction, for
                 // all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!";
                 ZipEntry e1 = zip.Entries[1];
                 CrcCalculatorStream crcStream = entry.OpenReader();
                 byte[] buffer = new byte[crcStream.Length];
                            int n, totalBytesRead = 0;
                            do
                            {
                                n = crcStream.Read(buffer, 0, buffer.Length);
                                totalBytesRead += n;
                           } while (n &gt; 0);
             }
             </code>
            
             </example>
             
             <exception cref="T:System.InvalidOperationException">
             Thrown in the setter if EncryptionAlgorithm.Unsupported is specified, or
             if setting the property on an entry Read from a zip archive.
             </exception>
            
             <seealso cref="P:Infragistics.Compression.ZipEntry.Password">ZipEntry.Password</seealso>
             <seealso cref="P:Infragistics.Compression.ZipFile.Encryption">ZipFile.Encryption</seealso>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.Password">
             <summary>
             The Password to be used when encrypting a <c>ZipEntry</c> upon
             <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
             </summary>
            
             <remarks>
             <para>
             This is a Write-only property on the entry. Set this to request that the
             entry be encrypted when writing the zip archive, or set it to specify the
             password to be used when extracting an existing entry that is encrypted.
             </para>
            
             <para>
             The password set here is implicitly used to encrypt the entry during the
             <see cref="M:Infragistics.Compression.ZipFile.Save(System.IO.Stream)"/> operation, or to decrypt during the 
              <see cref="M:Infragistics.Compression.ZipEntry.OpenReader"/> operation.  If you set the
             Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no effect.
             </para>
            
             <para>
             Consider setting the <see cref="P:Infragistics.Compression.ZipEntry.Encryption"/> property when using a
             password. Answering concerns that the standard password protection supported by
             all zip tools is weak, WinZip has extended the ZIP specification with a way to
             use AES Encryption to protect entries in the Zip file. Unlike the "PKZIP 2.0"
             encryption specified in the PKZIP specification, <see href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES Encryption</see>
             uses a standard, strong, tested, encryption algorithm. DotNetZip can create zip
             archives that use WinZip-compatible AES encryption, if you set the <see cref="P:Infragistics.Compression.ZipEntry.Encryption"/> property. But, archives created that use AES encryption may
             not be readable by all other tools and libraries. For example, Windows Explorer
             cannot Read a "compressed folder" (a zip file) that uses AES encryption, though
             it can Read a zip file that uses "PKZIP encryption."
             </para>
            
             <para>
             The <see cref="T:Infragistics.Compression.ZipFile"/> class also has a <see cref="P:Infragistics.Compression.ZipFile.Password"/>
             property.  This property takes precedence over any password set on the ZipFile
             itself.  Typically, you would use the per-entry Password when most entries in
             the zip archive use one password, and a few entries use a different password.
             If all entries in the zip file use the same password, then it is simpler to just
             set this property on the ZipFile itself, whether creating a zip archive or
             extracting a zip archive.
             </para>
            
             <para>
             Some comments on updating archives: If you Read a <c>ZipFile</c>, you cannot
             modify the password on any encrypted entry, except by extracting the entry
             with the original password (if any), removing the original entry via <see cref="P:Infragistics.Compression.ZipFile.Entries"/>, and then adding a new entry with a
             new Password.
             </para>
            
             <para>
             For example, suppose you Read a <c>ZipFile</c>, and there is an encrypted entry.
             Setting the Password property on that <c>ZipEntry</c> and then calling
             <c>Save()</c> on the <c>ZipFile</c> does not update the password on that entry in
             the archive.  Neither is an exception thrown. Instead, what happens during
             the <c>Save()</c> is the existing entry is copied through to the new zip
             archive, in its original encrypted form. Upon re-reading that archive, the
             entry can be decrypted with its original password.
             </para>
            
             <para>
             If you Read a ZipFile, and there is an un-encrypted entry, you can set the
             <c>Password</c> on the entry and then call Save() on the ZipFile, and get
             encryption on that entry.
             </para>
            
             </remarks>
            
             <example>
             <para>
             This example creates a zip file with two entries, and then extracts the
             entries from the zip file.  When creating the zip file, the two files are
             added to the zip file using password protection. Each entry uses a different
             password.  During extraction, each file is extracted with the appropriate
             password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 MemoryStream stream = new MemoryStream();
                 ZipEntry entry;
                 entry= ZipEntry.CreateFile("Declaration.txt");
                 entry.Password= "123456!";
                 entry = zip.Entries.Add("Report.xls");
                 entry.Password= "1Secret!";
                 zip.Save(stream);
             }
             
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim entry as ZipEntry
                 Dim stream as New MemoryStream     
                 entry= ZipEntry.CreateFile("Declaration.txt")
                 entry.Password= "123456!"
                 entry = zip.Entries.Add("Report.xls")
                 entry.Password= "1Secret!"
                 zip.Save(stream)
             End Using
             
             </code>
            
             </example>
             
             <seealso cref="P:Infragistics.Compression.ZipEntry.Encryption"/>
             <seealso cref="P:Infragistics.Compression.ZipFile.Password">ZipFile.Password</seealso>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.WillReadTwiceOnInflation">
             <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
            
             <remarks>
             <para>
             In some cases, applying the Deflate compression algorithm in DeflateStream can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the Compression library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
            
             <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-Check-sizes process as
             decribed above, is not done.
             </para>
            
             <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the Read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
            
             <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream.  As with other
             properties (like Password and ForceNoCompression), setting the corresponding
             delegate on the <c>ZipFile</c> class itself will set it on all <c>ZipEntry</c> items that are
             subsequently added to the <c>ZipFile</c> instance.
             </para>
            
             </remarks>
             <seealso cref="P:Infragistics.Compression.ZipFile.WillReadTwiceOnInflation"/>
             <seealso cref="T:Infragistics.Compression.ReReadApprovalCallback"/>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.WantCompression">
             <summary>
             A callback that allows the application to specify whether compression should
             be used for a given entry that is about to be added to the zip archive.
             </summary>
            
             <remarks>
             See <see cref="P:Infragistics.Compression.ZipFile.WantCompression"/>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.UseUnicodeAsNecessary">
             <summary>
             Set to indicate whether to use UTF-8 encoding for filenames and 
             comments.  
             </summary>
            
             <remarks>
            
             <para> If this flag is set, the comment and filename for the entry will be
             encoded with UTF-8, as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification</see>, if necessary. "Necessary" means, the filename or entry
             comment (if any) cannot be reflexively encoded and decoded using the default
             code page, UTF8.  </para>
            
             <para>
             Setting this flag to true is equivalent to setting
             <see cref="P:Infragistics.Compression.ZipEntry.ProvisionalAlternateEncoding"/> to <c>System.Text.Encoding.UTF8</c>.
             </para>
            
             <para> This flag has no effect or relation to the text encoding used within the file
             itself. </para>
            
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipEntry.ProvisionalAlternateEncoding">
             <summary>
             The text encoding to use for the FileName and Comment on this ZipEntry, when the 
             default encoding is insufficient.
             </summary>
            
             <remarks>
            
             <para>
             This is a long and odd name for a property, but there's a good reason for
             According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">
             the Zip specification from PKWare</see>, filenames and comments for a
             <c>ZipEntry</c> are encoded either with IBM437 or with UTF8.  But, some zip
             archiver tools or libraries do not follow the specification, and instead
             encode characters using the system default code page, or an arbitrary code
             page.  For example, WinRAR when run on a machine in Shanghai may encode
             filenames with the Chinese (Big-5) code page.  This behavior is contrary to
             the Zip specification, but it occurs anyway.  This property exists to
             support that non-compliant behavior when reading or writing zip files.
             </para>
            
             <para>
             When writing zip archives that will be Read by one of these other archivers,
             use this property to specify the code page to use when encoding filenames
             and comments into the zip file, when UTF8 will not suffice.
             </para>
            
             <para>
             When using an arbitrary, non-UTF8 code page for encoding, there is no
             standard way for the creator (Infragistics.Silverlight.Comression) to specify in 
             the zip file which code page has been used. DotNetZip is not able to inspect the zip file and
             determine the codepage used for the entries within it. Therefore, you, the
             application author, must determine that.  If you Read a zip file using a
             codepage other than the one used to encode the zipfile, this may result in
             filenames that are not legal in the filesystem, and you will get exceptions
             during calls to <c>ZipEntry.OpenReader()</c> methods for those entries.
             </para>
            
             </remarks>
        </member>
        <member name="T:Infragistics.Compression.ZipFile">
            <summary>
            The ZipFile type represents a zip archive file.  This is the main type in the
            DotNetZip class library.  This class reads and writes zip files, as defined in
            the format for zip described by PKWare.  The compression for this implementation
            Was, at one time, based on the System.IO.Compression.DeflateStream base class in
            the .NET Framework base class library, available in v2.0 and later of the .NET
            Framework. As of v1.7 of DotNetZip, the compression is provided by a
            managed-code version of Zlib, included with DotNetZip.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class, without specifying a target filename or stream to save to. 
            </summary>
            <remarks>
            <para> After instantiating with this constructor and adding entries to the
            archive, the application should call 
            <see cref="M:Infragistics.Compression.ZipFile.Save(System.IO.Stream)"/> to save to a file or a stream,
            respectively. </para>
            <para>
            Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
            have multiple threads that each use a distinct <c>ZipFile</c> instance, or
            you can synchronize multi-thread access to a single instance.  </para>
            </remarks>
            <example>
            This example creates a Zip archive called Backup.zip, containing all the files
            in the directory DirectoryToZip. Files within subdirectories are not zipped up.
            <code>
            using (ZipFile zip = new ZipFile())
            { 
              MemoryStream stream = new MemoryStream();
              ZipEntry entry = ZipEntry.CreateFile("test.txt");
              zip.Entries.Add(entry);
              zip.Save(stream);
            }
            </code>
            <code lang="VB">
            Using zip As New ZipFile
                Dim stream as New MemoryStream
                Dim entry As String() = ZipEntry.CreateFile("test.txt")
                zip.Entries.Add(entry)
                zip.Save(stream)
            End Using
            </code>
            </example>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class,
            using the specified  Stream to set ZipFile feratures
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.IO.Stream,System.EventHandler{Infragistics.Compression.ReadProgressEventArgs})">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="stream">The stream.</param>
            <param name="readProgress">The read progress.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.IO.Stream,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="stream">The stream.</param>
            <param name="password">The password.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.IO.Stream,System.String,System.EventHandler{Infragistics.Compression.ReadProgressEventArgs})">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="stream">The stream.</param>
            <param name="password">The password.</param>
            <param name="readProgress">The read progress.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class,
            using the specified  Stream to set ZipFile feratures
            </summary>
            <param name="buffer">The byte[] array.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.Byte[],System.EventHandler{Infragistics.Compression.ReadProgressEventArgs})">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="readProgress">The read progress.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.Byte[],System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="password">The password.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.Byte[],System.String,System.EventHandler{Infragistics.Compression.ReadProgressEventArgs})">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="password">The password.</param>
            <param name="readProgress">The read progress.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class, specifying a text Encoding, but without specifying a target
            filename or stream to save to.
            </summary>
            <param name="encoding">The Encoding is used as the default alternate encoding for entries with
            filenames or comments that cannot be encoded with the UTF8 code page.</param>
            <remarks>
            See the documentation on the <see cref="M:Infragistics.Compression.ZipFile.#ctor(System.Text.Encoding)">ZipFile constructor
            that accepts a single string argument</see> for basic information on all the
            <c>ZipFile</c> constructors.
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="stream">The stream.</param>
            <param name="encoding">The encoding.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.#ctor(System.Byte[],System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="encoding">The encoding.</param>
        </member>
        <member name="F:Infragistics.Compression.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is  UTF-8.        
            </summary>
            <seealso cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/>
            TODOPP:
            public readonly static System.Text.Encoding DefaultEncoding = System.Text.Encoding.GetEncoding("IBM437");        
        </member>
        <member name="M:Infragistics.Compression.ZipFile.Save(System.IO.Stream)">
            <summary>
            Save the zip archive to the specified stream.
            </summary>
            <remarks>
            <para>
            The <c>ZipFile</c> instance is written to storage - typically a zip file in a
            filesystem, but using this overload, the storage can be anything accessible via
            a writable stream - only when the caller calls <c>Save</c>.
            </para>
            <para>
            Use this Method to save the zip content to a stream directly.  A common
            scenario is an ASP.NET application that dynamically generates a zip file and
            allows the browser to download it. The application can call
            <c>Save(Response.OutputStream)</c> to Write a zipfile directly to the output
            stream, without creating a zip file on the disk on the ASP.NET server.
            </para>
            </remarks>
            <param name="outputStream">
            The <c>System.IO.Stream</c> to Write to. It must be writable.
            </param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.Reset">
            <summary>
            Resets this instance.
            Called by ZipEntry in ZipEntry.Extract(), when 
            there is no stream set for the ZipEntry.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.Finalize">
            <summary>
            Finalizes an instance of the <see cref="T:Infragistics.Compression.ZipFile"/> class, which gets called implicitly when the instance
            is destroyed.  Because the <c>ZipFile</c> type implements IDisposable, this
            Method calls Dispose(false).
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.Dispose">
            <summary>
            Handles closing of the Read and Write streams associated
            to the <c>ZipFile</c>, if necessary.  
            </summary>
            <remarks>
            The Dispose() Method is generally 
            employed implicitly, via a using() {} statement. (Using...End Using in VB)
            Always use a using statement, or always insure that you are calling Dispose() 
            explicitly.
            </remarks>
            <example>
            This example extracts an entry selected by name, from the Zip file to the
            Console.
            <code>
            using (ZipFile zip = ZipFile(Stream))
            {
              foreach (ZipEntry e in zip.Entries)
              {
                if (WantThisEntry(e.FileName)) 
                {
                  CrcCalculatorStream crcStream = e.OpenReader();
                  byte[] buffer = new byte[crcStream.Length];
                  int n, totalBytesRead = 0;
                  do
                  {
                     n = crcStream.Read(buffer, 0, buffer.Length);
                     totalBytesRead += n;
                  }while (n > 0);
                }
                  zip.Extract(e.FileName, Console.OpenStandardOutput());
              }
            } // Dispose() is called implicitly here.
            </code>
            </example>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.Dispose(System.Boolean)">
            <summary>
            The Dispose() Method.  It disposes any managed resources, 
            if the flag is set, then marks the instance disposed.
            This Method is typically not called from application code.
            </summary>
            <param name="disposeManagedResources">indicates whether the
            Method should dispose streams or not.</param>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.SelectEntries(System.String)">
            <summary>
            Retrieve entries from the zipfile by specified criteria.
            </summary>
            
            <remarks>
            <para>
            This Method allows callers to retrieve the collection of entries from the zipfile
            that fit the specified criteria.  The criteria are described in a string format, and
            can include patterns for the filename; constraints on the size of the entry;
            constraints on the Last modified, created, or Last accessed time for the file
            described by the entry; or the attributes of the entry.
            </para>
            
            <para>
            This Method is intended for use with a ZipFile that has been Read from storage.
            When creating a new ZipFile, this Method will work only after the ZipArchive has
            been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
            archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
            saved will deliver undefined results.
            </para>
            </remarks>
            
            <exception cref="T:System.Exception">
            Thrown if selectionCriteria has an invalid syntax.
            </exception>
            
            <example>
            This example selects all the PhotoShop files from within an archive, and extracts them
            to the current working directory.
            <code>
            using (ZipFile zip1 = ZipFile.Read(ZipFileName))
            {
                var PhotoShopFiles = zip1.SelectEntries("*.psd");
                foreach (ZipEntry psd in PhotoShopFiles)
                {
                    psd.Extract();
                }
            }
            </code>
            <code lang="VB">
            Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                Dim PhotoShopFiles as ICollection(Of ZipEntry)
                PhotoShopFiles = zip1.SelectEntries("*.psd")
                Dim psd As ZipEntry
                For Each psd In PhotoShopFiles
                    psd.Extract
                Next
            End Using
            </code>
            </example>
            <param name="selectionCriteria">the string that specifies which entries to select</param>
            <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.SelectEntries(System.String,System.String)">
             <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
             
             <remarks>
             <para>
             This Method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the Last modified, created, or Last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             This Method is intended for use with a ZipFile that has been Read from storage.
             When creating a new ZipFile, this Method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
             
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
             
             <example>
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
                 foreach (ZipEntry e in UpdatedPhotoShopFiles)
                 {
                     // prompt for extract here
                     if (WantExtract(e.FileName))
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
                 Dim e As ZipEntry
                 For Each e In UpdatedPhotoShopFiles
                     ' prompt for extract here
                     If Me.WantExtract(e.FileName) Then
                         e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
             
             <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in an enumeration.  
             </summary>
            
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead 
             it is implicitly called when you use a <see langword="foreach"/> loop in C#, or a 
             <c>For Each</c> loop in VB.NET.
             </remarks>
            
             <example>
             This example reads a zipfile of a given name, then enumerates the 
             entries in that zip file, and displays the information about each 
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
             
             <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZipFile.GetNewEnum">
             <summary>
             IEnumerator support, for use of a ZipFile in a foreach construct.  
             </summary>
            
             <remarks>
             This Method is included for COM support.  An application generally does not call
             this Method directly.  It is called implicitly by COM clients when enumerating
             the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
             statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
             </remarks>
            
             <returns>
             The IEnumerator over the entries in the ZipFile. 
             </returns>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.BufferSize">
            <summary>
            Gets or sets the size of the buffer used while saving.
            </summary>
            <remarks>
            <para>
            First, let me say that you really don't Need to bother with this.  It is
            here to allow for optimizations that you probably won't make! It will work
            fine if you don't set or get this property at all. Ok?
            </para>
            <para>
            Now that we have <em>that</em> out of the way, the fine print: This
            property affects the size of the buffer that is used for I/O for each entry
            contained in the zip file. When a file is Read in to be compressed, it uses
            a buffer given by the size here.  When you update a zip file, the data for
            unmodified entries is copied from the first zip file to the other, through a
            buffer given by the size here.
            </para>
            <para>
            Changing the buffer size affects a few things: first, for larger buffer
            sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
            during I/O operations.  This may make operations faster for very much larger
            files.  Last, for any given entry, when you use a larger buffer there will be
            fewer progress events during I/O operations, because there's one progress
            event generated for each time the buffer is filled and then emptied.
            </para>
            <para>
            The default buffer size is 8k.  Increasing the buffer size may speed things
            up as you compress larger files.  But there are no hard-and-fast rules here,
            eh?  You won't know til you test it.  And there will be a limit where ever
            larger buffers actually slow things down.  So as I said in the beginning,
            it's probably best if you don't set or get this property at all.
            </para>
            </remarks>
            <example>
            This example shows how you might set a large buffer size for efficiency when
            dealing with zip entries that are larger than 1gb. 
            <code lang="C#">
            using (ZipFile zip = new ZipFile())
            {
                MemoryStream stream = new MemoryStream();
                zip.SaveProgress += this.zip1_SaveProgress;
                zip.Entries.Add(ZipEntry.CreateDirectory(directoryToZip);
                zip.UseZip64WhenSaving = Zip64Option.Always;
                zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                zip.Save(stream);
            }
            </code>
            </example>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.CaseSensitiveRetrieval">
            <summary>
            Gets or sets a value indicating whether to perform case-sensitive matching on the filename when
            retrieving entries in the zipfile via the string-based indexer.
            </summary>
            <remarks>
            The default value is <c>false</c>, which means DON'T do case-sensitive
            matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
            zip["readme.txt"].  It really makes sense to set this to <c>true</c> only if
            you are not running on Windows, which has case-insensitive filenames. But
            since this library is not built for non-Windows platforms, in most cases you
            should just leave this property alone.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.CodecBufferSize">
            <summary>
            Gets or sets the size of the work buffer to use for the Zlib codec during compression.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Comment">
            <summary>
            Gets or sets a comment attached to the zip archive.
            </summary>
            <remarks>
            <para>
            This property is Read/Write. It allows the application to specify a comment
            for the <c>ZipFile</c>, or Read the comment for the <c>ZipFile</c>.  After
            setting this property, changes are only made permanent when you call a
            <c>Save()</c> Method.
            </para>
            <para>
            According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
            specification</see>, the comment is not encrypted, even if there is a
            password set on the zip file.
            </para>
            <para>
            The zip spec does not describe how to encode the comment string in a code
            page other than IBM437. Silverlight however uses UTF* by default so comments will use UTF8.  However, there are situations where you want an
            encoded Comment, for example using code page 950 "Big-5 Chinese".  Compression library
            will encode the comment in the code page specified by <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/>, at the time of the call to
            ZipFile.Save(Stream).
            </para>
            <para>
            When creating a zip archive using this library, it is possible to change the
            value of <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/> between each entry you
            add, and between adding entries and the call to Save(). Don't do this.  It
            will likely result in a zipfile that is not readable by any tool or
            application.  For best interoperability, leave <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/> alone, or specify it only once,
            before adding any entries to the <c>ZipFile</c> instance.
            </para>
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.CompressionLevel">
            <summary>
            Gets or sets the compression level to be used for entries when saving the zip archive.
            </summary>
            <value>The compression level.</value>
            <remarks>
            The compression level setting is used at the time of <c>Save()</c>. The same
            level is applied to all <c>ZipEntry</c> instances contained in the
            <c>ZipFile</c> during the save.  If you do not set this property, the
            default compression level is used, which normally gives a good balance of
            compression efficiency and compression speed.  In some tests, using
            <c>BestCompression</c> can double the time it takes to compress, while
            delivering just a small increase in compression efficiency.  This behavior
            will vary with the type of data you compress.  If you are in doubt, just
            leave this setting alone, and accept the default.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.EmitTimesInUnixFormatWhenSaving">
            <summary>
            Gets or sets a value indicating whether the Creation, Access, and Modified times
            for entries added to the zip file will be emitted in "Unix(tm)
            format" when the zip archive is saved.
            </summary>
            <remarks>
            <para>
            An application creating a zip archive can use this flag to explicitly
            specify that the file times for the entries should or should not be stored
            in the zip archive in the format used by Unix. By default this flag is
            <c>false</c>.
            </para>
            <para>
            When adding an entry from a file or directory, the Creation (<see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>), Access (<see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>), and
            Modified (<see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>) times for the given entry are
            automatically set from the filesystem values. When adding an entry from a
            stream or string, all three values are implicitly set to DateTime.Now.
            Applications can also explicitly set those times by calling <see cref="M:Infragistics.Compression.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
            </para>
            <para>
            <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
            zip specification</see> describes multiple ways to format these times in a
            zip file. One is the format Windows applications normally use: 100ns ticks
            since Jan 1, 1601 UTC.  The other is a format Unix applications typically
            use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an "extra
            field" in the zip entry when saving the zip archive. The former uses an
            extra field with a Header Id of 0x000A, while the latter uses a header ID of
            0x5455.
            </para>
            <para>
            Not all tools and libraries can interpret these fields.  Windows compressed
            folders is one that can Read the Windows Format timestamps, while I believe
            the <see href="http://www.info-zip.org/">Infozip</see> tools can Read the Unix
            format timestamps. Some tools and libraries may be able to Read only one or
            the other.
            </para>
            <para>
            The times stored are taken from <see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>, <see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>, and <see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>.
            </para>
            <para>
            This property is not mutually exclusive of the <see cref="P:Infragistics.Compression.ZipFile.EmitTimesInWindowsFormatWhenSaving"/> property.  It is possible and
            legal and valid to produce a zip file that contains timestamps encoded in
            the Unix format as well as in the Windows format.  I haven't got a complete
            list of tools and which sort of timestamps they can use and will
            tolerate. You'll have to test it yourself.  If you get any good information
            and would like to pass it on, please do so and I will include that
            information in this documentation.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
            <seealso cref="P:Infragistics.Compression.ZipFile.EmitTimesInWindowsFormatWhenSaving"/>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.EmitTimesInWindowsFormatWhenSaving">
            <summary>
            Gets or sets a value indicating whether the Creation, Access, and Modified times
            for entries added to the zip file will be emitted in "Unix(tm)
            format" when the zip archive is saved.
            </summary>
            <remarks>
            <para>
            An application creating a zip archive can use this flag to explicitly
            specify that the file times for the entries should or should not be stored
            in the zip archive in the format used by Unix. By default this flag is
            <c>false</c>.
            </para>
            <para>
            When adding an entry from a file or directory, the Creation (<see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>), Access (<see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>), and
            Modified (<see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>) times for the given entry are
            automatically set from the filesystem values. When adding an entry from a
            stream or string, all three values are implicitly set to DateTime.Now.
            Applications can also explicitly set those times by calling <see cref="M:Infragistics.Compression.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
            </para>
            <para>
            <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
            zip specification</see> describes multiple ways to format these times in a
            zip file. One is the format Windows applications normally use: 100ns ticks
            since Jan 1, 1601 UTC.  The other is a format Unix applications typically
            use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an "extra
            field" in the zip entry when saving the zip archive. The former uses an
            extra field with a Header Id of 0x000A, while the latter uses a header ID of
            0x5455.
            </para>
            <para>
            Not all tools and libraries can interpret these fields.  Windows compressed
            folders is one that can Read the Windows Format timestamps, while I believe
            the <see href="http://www.info-zip.org/">Infozip</see> tools can Read the Unix
            format timestamps. Some tools and libraries may be able to Read only one or
            the other.
            </para>
            <para>
            The times stored are taken from <see cref="P:Infragistics.Compression.ZipEntry.ModifiedTime"/>, <see cref="P:Infragistics.Compression.ZipEntry.AccessTime"/>, and <see cref="P:Infragistics.Compression.ZipEntry.CreationTime"/>.
            </para>
            <para>
            The value set here applies to all entries subsequently added to the
            <c>ZipFile</c>.
            </para>
            <para>
            This property is not mutually exclusive of the <see cref="P:Infragistics.Compression.ZipFile.EmitTimesInUnixFormatWhenSaving"/> property.  It is possible and
            legal and valid to produce a zip file that contains timestamps encoded in
            the Unix format as well as in the Windows format.  I haven't got a complete
            list of tools and which sort of timestamps they can use and will
            tolerate. You'll have to test it yourself.  If you get any good information
            and would like to pass it on, please do so and I will include that
            information in this documentation.
            </para>
            </remarks>
            <example>
            This example shows how to save a zip file that contains file timestamps
            in a format normally used by Unix.
            <code lang="C#">
            using (var zip = new ZipFile())
            {
                zip.EmitTimesInWindowsFormatWhenSaving = false;
                zip.EmitTimesInUnixFormatWhenSaving = true;
                zip.AddDirectory(directoryToZip, "files");
                zip.Save(outputFile);
            }
            </code>
            <code lang="VB">
            Using zip As New ZipFile
                zip.EmitTimesInWindowsFormatWhenSaving = False
                zip.EmitTimesInUnixFormatWhenSaving = True
                zip.AddDirectory(directoryToZip, "files")
                zip.Save(outputFile)
            End Using
            </code>
            </example>
            <seealso cref="P:Infragistics.Compression.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
            <seealso cref="P:Infragistics.Compression.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.ForceNoCompression">
            <summary>
            Gets or sets a value indicating whether flag whether the <c>ZipFile</c> should use
            compression for subsequently added entries in the <c>ZipFile</c> instance.
            </summary>
            <remarks>
            <para> When saving an entry into a zip archive, the Compression library by default
            compresses the file. That's what a ZIP archive is all about, isn't it?  For
            files that are already compressed, like MP3's or JPGs, the deflate algorithm
            can actually slightly expand the size of the data.  Setting this property to
            trye allows you to specify that compression should not be used.  The default
            value is false.  </para>
            <para>
            Do not construe setting this flag to false as "Force Compression".  Setting
            it to false merely does NOT force No compression.  If you want to force the
            use of the deflate algorithm when storing each entry into the zip archive,
            define a <see cref="P:Infragistics.Compression.ZipFile.WillReadTwiceOnInflation"/> callback, which always
            returns false, and a <see cref="P:Infragistics.Compression.ZipFile.WantCompression"/> callback that always
            returns true.  This is probably the wrong thing to do, but you could do
            it. Forcing the use of the Deflate algorithm when storing an entry does not
            guarantee that the data size will get smaller. It could increase, as
            described above.
            </para>
            <para>
            Changes to this flag apply to all entries subsequently added to the archive. 
            The application can also set the <see cref="P:Infragistics.Compression.ZipEntry.CompressionMethod"/>
            property on each ZipEntry, for more granular control of this capability.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipEntry.CompressionMethod"/>
            <seealso cref="P:Infragistics.Compression.ZipFile.CompressionLevel"/>
            <seealso cref="P:Infragistics.Compression.ZipFile.WantCompression"/>
            <example>
            This example shows how to specify that Compression will not be used when
            adding files to the zip archive. None of the files added to the archive in
            this example will use compression.
            <code>
            using (ZipFile zip = new ZipFile())
            {
              MemoryStream stream = new MemoryStream();
              zip.ForceNoCompression = true;
              ZipEntry e1 = ZipEntry.CreateDirectory(@"c:\reports\January");
              zip.Entries.Add(e1);
              zip.Comment = "All files in this archive will be uncompressed.";
              zip.Save(stream);
            }
            </code>
            <code lang="VB">
            Using zip As New ZipFile()
              Dim stream as New MemoryStream
              zip.ForceNoCompression = true
              Dim e1 as ZipEntry = ZipEntry.CreateDirectory(@"c:\reports\January")
              zip.Entries.Add(e1)
              zip.Comment = "All files in this archive will be uncompressed."
              zip.Save(stream)
            End Using
            </code>
            </example>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Fullscan">
            <summary>
            Gets or sets a value indicating whether to perform a full scan of the zip file when reading it. 
            </summary>
            <remarks>
            <para>
            When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
            VB), the entire zip archive will be scanned and searched for entries.
            For large archives, this can take a very, long time. The much more
            efficient default behavior is to Read the zip directory, at the End of
            the zip file. However, in some cases the directory is corrupted and it
            is desirable to perform a full scan of the zip file to determine the
            contents of the zip file.
            </para>
            <para>
            If you want to track progress, you can set the ReadProgress event. 
            </para>
            <para>
            This flag is effective only when calling Initialize.  The Initialize
            Method may take a long time to run for large zip files, when
            <c>Fullscan</c> is true.
            </para>
            </remarks>
            <example>
            This example shows how to Read a zip file using the full scan approach,
            and then save it, thereby producing a corrected zip file. 
            <code lang="C#">
            using (var zip = new ZipFile())
            {
                zip.Fullscan = true;
                zip.Initialize(zipFileName);
                zip.Save(newName);
            }
            </code>
            <code lang="VB">
            Using zip As New ZipFile
                zip.Fullscan = True
                zip.Initialize(zipFileName)
                zip.Save(newName)
            End Using
            </code>
            </example>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Item(System.Int32)">
            <summary>
            This is an integer indexer into the Zip archive.
            </summary>
            <remarks>
            <para>
            This property is Read-Write. But don't get too excited: When setting the
            value, the only legal value is <c>null</c> (<c>Nothing</c> in VB). If you
            assign a non-null value, the setter will throw an exception.
            </para>
            <para>
            Setting the value to <c>null</c> is equivalent to calling <see cref="M:Infragistics.Compression.ZipFile.RemoveEntry(System.String)"/> with the filename for the given entry.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if the caller attempts to assign a non-null value to the indexer, 
            or if the caller uses an out-of-range Index value.
            </exception>
            <param name="ix">
            The Index value.
            </param>
            <returns>
            The <c>ZipEntry</c> within the Zip archive at the specified Index. If the 
            entry does not exist in the archive, this indexer throws.
            </returns>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Item(System.String)">
            <summary>
            This is a name-based indexer into the Zip archive.  
            </summary>
            <remarks>
            <para>
            Retrieval by the string-based indexer is done on a case-insensitive basis,
            by default.  Set the <see cref="P:Infragistics.Compression.ZipFile.CaseSensitiveRetrieval"/> property to use
            case-sensitive comparisons.
            </para>
            <para>
            If you assign a non-null value, the setter will throw an exception.
            </para>
            <para>
            It is can be true that <c>this[value].FileName == value</c>, but not
            always. In other words, the <c>FileName</c> property of the <c>ZipEntry</c>
            you retrieve with this indexer, can be equal to the Index value, but not
            always.  In the case of directory entries in the archive, you may retrieve
            them with the name of the directory with no trailing slash, even though in
            the entry itself, the actual <see cref="P:Infragistics.Compression.ZipEntry.FileName"/> property may
            include a trailing slash.  In other words, for a directory entry named
            "dir1", you may find <c>zip["dir1"].FileName == "dir1/"</c>. Also, for any
            entry with slashes, they are stored in the zip file as forward slashes, but
            you may retrieve them with either forward or backslashes.  So,
            <c>zip["dir1\\entry1.txt"].FileName == "dir1/entry.txt"</c>.
            </para>
            </remarks>
            <example>
            This example extracts only the entries in a zip file that are .txt files.
            <code>
            using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
            {
              foreach (string s1 in zip.EntryFilenames)
              {
                if (s1.EndsWith(".txt"))
                  zip[s1].Extract("textfiles");
              }
            }
            </code>
            <code lang="VB">
              Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                  Dim s1 As String
                  For Each s1 In zip.EntryFilenames
                      If s1.EndsWith(".txt") Then
                          zip(s1).Extract("textfiles")
                      End If
                  Next
              End Using
            </code>
            </example>        
            <exception cref="T:System.ArgumentException">
            Thrown if the caller attempts to assign a non-null value to the indexer.
            </exception>
            <param name="fileName">
            The name of the file, including any directory path, to retrieve from the zip. 
            The filename match is not case-sensitive by default; you can use the
            <see cref="P:Infragistics.Compression.ZipFile.CaseSensitiveRetrieval"/> property to change this behavior. The
            pathname can use forward-slashes or backward slashes.
            </param>
            <returns>
            The <c>ZipEntry</c> within the Zip archive, given by the specified
            filename. If the named entry does not exist in the archive, this indexer
            returns <c>null</c> (<c>Nothing</c> in VB).
            </returns>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.OutputUsedZip64">
            <summary>
            Gets a value indicating whether the most recent <c>Save()</c> operation used ZIP64 extensions.
            </summary>
            <remarks>
            <para>
            The use of ZIP64 extensions within an archive is not always necessary, and for
            interoperability concerns, it may be desired to NOT use ZIP64 if possible.  The
            <see cref="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving"/> property can be set to use ZIP64
            extensions only when necessary.  In those cases, Sometimes applications want to
            know whether a Save() actually used ZIP64 extensions.  Applications can query
            this Read-only property to learn whether ZIP64 has been used in a just-saved
            <c>ZipFile</c>.
            </para>
            <para>
            The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
            been saved.
            </para>
            <para>
            Non-null values (<c>HasValue</c> is true) indicate whether ZIP64 extensions
            were used during the most recent <c>Save()</c> operation.  The ZIP64
            extensions may have been used as required by any particular entry because of
            its uncompressed or compressed size, or because the archive is larger than
            4294967295 bytes, or because there are more than 65534 entries in the
            archive, or because the <c>UseZip64WhenSaving</c> property Was set to <see cref="F:Infragistics.Compression.Zip64Option.Always"/>, or because the <c>UseZip64WhenSaving</c>
            property Was set to <see cref="F:Infragistics.Compression.Zip64Option.AsNecessary"/> and the output
            stream Was not seekable.  The value of this property does not indicate the
            reason the ZIP64 extensions were used.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving"/>
            <seealso cref="P:Infragistics.Compression.ZipFile.RequiresZip64"/>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Infragistics.Compression.ZipFile.Password" -->
        <member name="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding">
            <summary>
            Gets or sets a value indicating the text encoding to use when writing new entries to the <c>ZipFile</c>, for
            those entries that cannot be encoded with the default (UTF8) encoding; or,
            the text encoding that Was used when reading the entries from the
            <c>ZipFile</c>.
            </summary>
            <remarks>
            <para>
            In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
            zip specification</see>, PKWare describes two options for encoding filenames
            and comments: using IBM437 or UTF-8.  But, some archiving tools or libraries
            do not follow the specification, and instead encode characters using the
            system default code page.  For example, WinRAR when run on a machine in
            Shanghai may encode filenames with the Big-5 Chinese (950) code page.  This
            behavior is contrary to the Zip specification, but it occurs anyway.
            </para>   
            <para>
            Be aware that a zip file created after you've explicitly set the <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/> property to a value other than IBM437
            may not be compliant to the PKWare specification, and may not be readable by
            compliant archivers.  On the other hand, many (most?) archivers are
            non-compliant and can Read zip files created in arbitrary code pages.  The
            trick is to use or specify the proper codepage when reading the zip.
            </para>
            <para>
            When creating a zip archive using this library, it is possible to change the
            value of <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/> between each entry you
            add, and between adding entries and the call to Save(). Don't do this. It
            will likely result in a zipfile that is not readable.  For best
            interoperability, either leave <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/>
            alone, or specify it only once, before adding any entries to the
            <c>ZipFile</c> instance.  There is one exception to this recommendation,
            described later.
            </para>
            <para>
            When using an arbitrary, non-UTF8 code page for encoding, there is no
            standard way for the creator application - whether Compression 
            DotNetZip, WinZip, or something else - to formally specify in the zip file which
            codepage has been used for the entries. As a result, readers of zip files
            are not able to inspect the zip file and determine the codepage that Was
            used for the entries contained within it.  It is Left to the application or
            user to determine the necessary codepage when creating zip files encoded this
            way.  If you use an incorrect codepage when reading a zipfile, you will get
            entries with filenames that are incorrect, and the incorrect filenames may
            even contain characters that are not legal for use within filenames in
            Windows. Extracting entries with illegal characters in the filenames will
            lead to exceptions. It's too bad, but this is just the way things are with
            code pages in zip files.
            </para>
            <para>
            When using Compression to create a zip archive, 
            and the zip archive uses an  arbitrary code page, you must specify the encoding 
            to use  when the <c>Zipfile</c> is created.
            </para>
            <para>
            And now, the exception to the rule described above.  One strategy for
            specifying the code page for a given zip file is to describe the code page
            in a human-readable form in the Zip comment. For example, the comment may
            Read "Entries in this archive are encoded in the Big5 code page".  For
            maximum interoperability, the zip comment in this case should be encoded in
            the default, UTF8 code page.  In this case, the zip comment is encoded
            using a different page than the filenames.  To do this, Specify
            <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
            page, once before adding any entries, and then reset
            <c>ProvisionalAlternateEncoding</c> to UTF8 before setting the <see cref="P:Infragistics.Compression.ZipFile.Comment"/> property and calling Save().
            </para>
            </remarks>
            <seealso cref="F:Infragistics.Compression.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.RequiresZip64">
            <summary>
            Gets a value, indicating whether the archive requires ZIP64 extensions.
            </summary>
            <remarks>
            <para>
            This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not been
            saved, and there are fewer than 65334 ZipEntry items contained in the archive.
            </para>
            <para>
            The <c>Value</c> is true if any of the following four conditions holds: the
            uncompressed size of any entry is larger than 0xFFFFFFFF; the compressed
            size of any entry is larger than 0xFFFFFFFF; the relative offset of any
            entry within the zip archive is larger than 0xFFFFFFFF; or there are more
            than 65534 entries in the archive.  (0xFFFFFFFF = 4,294,967,295).  The
            result may not be known until a Save() is attempted on the zip archive.  The
            Value of this <see cref="T:System.Nullable"/> property may be set only AFTER
            one of the Save() methods has been called.
            </para>
            <para>
            If none of the four conditions holds, and the archive has been saved, then
            the Value is false.
            </para>
            <para>
            A <c>Value</c> of false does not indicate that the zip archive, as saved,
            does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
            archive may use ZIP64 even when not required if the <see cref="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving"/> property is set to <see cref="F:Infragistics.Compression.Zip64Option.Always"/>, or if the <see cref="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving"/> property is set to <see cref="F:Infragistics.Compression.Zip64Option.AsNecessary"/> and the output stream Was not seekable. Use
            the <see cref="P:Infragistics.Compression.ZipFile.OutputUsedZip64"/> property to determine if the most recent
            <c>Save()</c> Method resulted in an archive that utilized the ZIP64
            extensions.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving"/>
            <seealso cref="P:Infragistics.Compression.ZipFile.OutputUsedZip64"/>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Strategy">
            <summary>
            Gets or sets the compression strategy to use for all entries.
            </summary>
            <remarks>
            This refers to the Strategy used by the Zlib-compatible compressor. Different
            compression strategies work better on different sorts of data. The strategy parameter
            can affect the compression ratio and the speed of compression but not the correctness
            of the compression.  For more information see <see cref="T:Infragistics.Compression.CompressionStrategy"/>.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.UseUnicodeAsNecessary">
            <summary>
            Gets or sets a value indicating whether to encode entry filenames and entry comments using Unicode 
            (UTF-8).
            </summary>
            <remarks>
            <para>
            <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
            PKWare zip specification</see> provides for encoding file names and file
            comments in either the IBM437 code page, or in UTF-8.  This flag selects the
            encoding according to that specification. 
            </para>
            <para>
            Zip files created with strict adherence to the PKWare specification with
            respect to UTF-8 encoding can contain entries with filenames containing any
            combination of Unicode characters, including the full range of characters
            from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other alphabets.
            However, because at this time, the UTF-8 portion of the PKWare specification
            is not broadly supported by other zip libraries and utilities, such zip
            files may not be readable by your favorite zip tool or archiver. In other
            words, interoperability will decrease if you set this flag to true.
            </para>
            <para>
            In particular, Zip files created with strict adherence to the PKWare
            specification with respect to UTF-8 encoding will not work well with
            Explorer in Windows XP or Windows Vista, because Windows compressed folders,
            as far as I know, do not support UTF-8 in zip files.  Vista can Read the zip
            files, but shows the filenames incorrectly. Unpacking from Windows Vista
            Explorer will result in filenames that have rubbish characters in place of
            the high-order UTF-8 bytes.
            </para>
            <para>
            Also, zip files that use UTF-8 encoding will not work well with Java
            applications that use the java.util.zip classes, as of v5.0 of the Java
            runtime. The Java runtime does not correctly implement the PKWare
            specification in this regard.
            </para>
            <para>
            As a result, we have the unfortunate situation that "correct" behavior by the
            Compression library with regard to Unicode encoding of filenames during zip
            creation will result in zip files that are readable by strictly compliant and
            current tools (for example the most recent release of the commercial WinZip
            tool); but these zip files will not be readable by various other tools or
            libraries, including Windows Explorer.
            </para>
            <para>
            The Compression library can Read and Write zip files with UTF8-encoded
            entries, according to the PKware spec.  If you use Compression for both
            creating and reading the zip file, and you use UTF-8, there will be no loss
            of information in the filenames. For example, using a self-extractor created
            by this library will allow you to unpack files correctly with no loss of
            information in the filenames.
            </para>
            <para>        
            If you do not set this flag, it will remain false.  If this flag is false,
            your ZipFile will encode all filenames and comments using the UTF8
            codepage.  This is the default language for Silverlight.
            </para>
            <para>
            The loss of information associated to the use of the IBM437 encoding is
            inconvenient, and can also lead to runtime errors. For example, using
            IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
            your application creates a ZipFile, then adds two files, each with names of
            four Chinese characters each, this will result in a duplicate filename
            exception.  In the case where you add a single file with a name containing
            four Chinese characters, calling Extract() on the entry that has question
            marks in the filename will result in an exception, because the question mark
            is not legal for use within filenames on Windows.  These are just a few
            examples of the problems associated to loss of information.
            </para>
            <para>
            This flag is independent of the encoding of the content within the entries
            in the zip file. Think of the zip file as a container - it supports an
            encoding.  Within the container are other "containers" - the file entries
            themselves.  The encoding within those entries is independent of the
            encoding of the zip archive container for those entries.
            </para>
            <para>
            Rather than specify the encoding in a binary fashion using this flag, an
            application can specify an arbitrary encoding via the <see cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/> property.  Setting the encoding
            explicitly when creating zip archives will result in non-compliant zip files
            that, curiously, are fairly interoperable.  The challenge is, the PKWare
            specification does not provide for a way to specify that an entry in a zip
            archive uses a code page that is not UTF-8.  Therefore if you
            set the encoding explicitly when creating a zip archive, you must take care
            upon reading the zip archive to use the same code page.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.UseZip64WhenSaving">
            <summary>
            Gets or sets a value, indicating whether to use ZIP64 extensions when saving a zip archive. 
            </summary>
            <remarks>
            <para>
            Designed many years ago, the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
            specification from PKWARE</see> allowed for 32-bit quantities for the
            compressed and uncompressed sizes of zip entries, as well as a 32-bit
            quantity for specifying the length of the zip archive itself, and a maximum
            of 65535 entries.  These limits are now regularly exceeded in many backup
            and archival scenarios.  Recently, PKWare added extensions to the original
            zip spec, called "ZIP64 extensions", to raise those limitations.  This
            property governs whether the <c>ZipFile</c> instance will use those
            extensions when writing zip archives within a call to one of the Save()
            methods.  The use of these extensions is optional and explicit in Compression
            because, despite the Status of ZIP64 as a bona fide standard, many other zip
            tools and libraries do not support ZIP64, and therefore a zip file saved
            with ZIP64 extensions may be unreadable by some of those other tools.
            </para>
            <para>
            Set this property to <see cref="F:Infragistics.Compression.Zip64Option.Always"/> to always use ZIP64
            extensions when saving, regardless of whether your zip archive needs it.
            Suppose you add 5 files, each under 100k, to a ZipFile.  If you specify
            Always for this flag before calling the Save() Method, you will get a ZIP64
            archive, though you do not Need to use ZIP64 because none of the original
            zip limits had been exceeded.
            </para>
            <para>
            Set this property to <see cref="F:Infragistics.Compression.Zip64Option.Never"/> to tell the Compression
            library to never use ZIP64 extensions.  This is useful for maximum
            compatibility and interoperability, at the expense of the capability of
            handling large files or large archives. 
            </para>
            <para>
            Set this property to <see cref="F:Infragistics.Compression.Zip64Option.AsNecessary"/> to tell the
            DotNetZip library to use the zip64 extensions when required by the
            entry. After the file is compressed, the original and compressed sizes are
            checked, and if they exceed the limits described above, then zip64 can be
            used.
            </para>
            <para>
            The default value for the property is <see cref="F:Infragistics.Compression.Zip64Option.Never"/>. <see cref="F:Infragistics.Compression.Zip64Option.AsNecessary"/> is safest, in the sense that you will not
            get an Exception if a pre-ZIP64 limit is exceeded.
            </para>
            <para>
            You may set the property at any time before calling Save(). 
            </para>
            <para>
            The <c>ZipFile(Stream)</c> ctor will properly Read ZIP64-endowed zip
            archives, regardless of the value of this property.  Compression will always
            Read ZIP64 archives.  This property governs whether Compression will Write
            them. Therefore, when updating archives, be careful about setting this
            property after reading an archive that may use ZIP64 extensions.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Encryption">
            <summary>
            Gets or sets the Encryption to use for entries added to the <c>ZipFile</c>.
            </summary>
            <remarks>
            <para>
            Set this when creating a zip archive, or when updating a zip archive. The
            specified Encryption is applied to the entries subsequently added to the
            <c>ZipFile</c> instance.  Applications do not Need to set <c>Encryption</c>
            when reading or extracting a zip archive.
            </para>
            <para>
            If you set this to something other than EncryptionAlgorithm.None, you will also
            Need to set the <see cref="P:Infragistics.Compression.ZipFile.Password"/>.
            </para>
            <para>
            As with other properties (like <see cref="P:Infragistics.Compression.ZipFile.Password"/> and <see cref="P:Infragistics.Compression.ZipFile.ForceNoCompression"/>), setting this property a <c>ZipFile</c>
            instance will cause that <c>EncryptionAlgorithm</c> to be used on all <see cref="T:Infragistics.Compression.ZipEntry"/> items that are subsequently added to the <c>ZipFile</c>
            instance. In other words, if you set this property after you have added
            items to the <c>ZipFile</c>, but before you have called <c>Save()</c>, those
            items will not be encrypted or protected with a password in the resulting
            zip archive. To get a zip archive with encrypted entries, set this property,
            along with the <see cref="P:Infragistics.Compression.ZipFile.Password"/> property, before calling
            <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on
            the <c>ZipFile</c> instance.
            </para>
            <para>
            Some comments on updating archives: If you Read a <c>ZipFile</c>, you cannot
            modify the Encryption on any encrypted entry, except by extracting the entry
            with the original password (if any), removing the original entry via <see cref="!:ZipFile.Entries.Remove(ZipEntry)"/>, and then adding a new entry with a
            new Password and Encryption setting.
            </para>
            <para>
            For example, suppose you Read a <c>ZipFile</c>, and there is an encrypted
            entry.  Setting the Encryption property on that <c>ZipFile</c> and then
            calling <c>Save()</c> on the <c>ZipFile</c> does not update the Encryption
            used for the entries in the archive.  Neither is an exception
            thrown. Instead, what happens during the <c>Save()</c> is that all
            previously existing entries are copied through to the new zip archive, with
            whatever encryption and password that Was used when originally creating the
            zip archive. Upon re-reading that archive, to extract entries, applications
            should use the original password or passwords, if any.
            </para>
            </remarks>
            <example>
            <para>
            This example creates a zip archive that uses encryption, and then extracts
            entries from the archive.  When creating the zip archive, the ReadMe.txt
            file is zipped without using a password or encryption.  The other files use
            encryption.
            </para>
            <code>
            // Create a zip archive with AES Encryption.
            using (ZipFile zip = new ZipFile())
            {
                ZipEntry entry = ZipEntry.CreateFile("ReadMe.txt, "/", "My Data");
                zip.Entries.Add(entry);
                zip.Password= "Top.Secret.No.Peeking!";
                zip.Encryption= EncryptionAlgorithm.PkzipWeak;
                ZipEntry entry2 = ZipEntry.CreateFile("ReadMe2.txt, "/", "My New Data");
                zip.Entries.Add(entry);
                MemoryStream stream = new MemoryStream();
                zip.Save(stream);
            
            }
            </code>
            </example>
            <seealso cref="P:Infragistics.Compression.ZipFile.Password">ZipFile.Password</seealso>
            <seealso cref="P:Infragistics.Compression.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.WillReadTwiceOnInflation">
            <summary>
            Gets or sets a callback that allows the application to specify whether multiple reads of the
            stream should be performed, in the case that a compression operation actually
            inflates the size of the file data.  
            </summary>
            <remarks>
            <para>
            In some cases, applying the Deflate compression algorithm in
            <c>DeflateStream</c> can result an increase in the size of the data.  This
            "inflation" can happen with previously compressed files, such as a zip, jpg,
            png, mp3, and so on.  In a few tests, inflation on zip files can be as large
            as 60%!  Inflation can also happen with very small files.  In these cases,
            by default, the Compression library discards the compressed bytes, and stores
            the uncompressed file data into the zip archive.  This is an optimization
            where smaller size is preferred over longer run times.
            </para>
            <para>
            The application can specify that compression is not even tried, by setting the
            ForceNoCompression flag.  In this case, the compress-and-Check-sizes process as
            decribed above, is not done.
            </para>
            <para>
            In some cases, neither choice is optimal.  The application wants compression,
            but in some cases also wants to avoid reading the stream more than once.  This
            may happen when the stream is very large, or when the Read is very expensive, or
            when the difference between the compressed and uncompressed sizes is not
            significant.
            </para>
            <para>
            To satisfy these applications, this delegate allows the Compression library to ask
            the application to for approval for re-reading the stream, in the case where
            inflation occurs.  The callback is invoked only in the case of inflation; that
            is to say when the uncompressed stream is smaller than the compressed stream.
            </para>
            <para>
            As with other properties (like <see cref="P:Infragistics.Compression.ZipFile.Password"/> and <see cref="P:Infragistics.Compression.ZipFile.ForceNoCompression"/>), setting the corresponding delegate on a
            <c>ZipFile</c> instance will caused it to be applied to all ZipEntry items
            that are subsequently added to the <c>ZipFile</c> instance. In other words,
            if you set this callback after you have added files to the <c>ZipFile</c>,
            but before you have called Save(), those items will not be governed by the
            callback when you do call Save(). Your best bet is to set this callback
            before adding any entries.
            </para>
            <para>
            Of course, if you want to have different callbacks for different entries,
            you may do so.
            </para>
            </remarks>
            <example>
            <para>
            In this example, the application callback checks to see if the difference
            between the compressed and uncompressed data is greater than 25%.  If it is,
            then the callback returns true, and the application tells the library to
            re-Read the stream.  If not, then the callback returns false, and the
            library just keeps the "inflated" file data.
            </para>
            <code>
            public bool ReadTwiceCallback(long uncompressed, long compressed, string filename)
            {
                return ((uncompressed * 1.0/compressed) &gt; 1.25);
            }
            public void CreateTheZip()
            {
                using (ZipFile zip = new ZipFile())
                {
                    // set the callback before adding files to the zip
                    MemopryStream stream = new MemoryStream();
                    zip2.WillReadTwiceOnInflation = ReadTwiceCallback;
            
                    zip2.Enreies.Add(ZipEntry.CreateFile(filename1));
                    zip2.Enreies.Add(ZipEntry.CreateFile(filename2);
                    zip2.Save(stream);
                }
            }
            </code>
            </example>
            <seealso cref="P:Infragistics.Compression.ZipFile.WantCompression"/>
            <seealso cref="T:Infragistics.Compression.WantCompressionCallback"/>
            <seealso cref="P:Infragistics.Compression.ZipEntry.WillReadTwiceOnInflation"/>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.WantCompression">
            <summary>
            Gets or sets a callback that allows the application to specify whether compression should
            be used for entries subsequently added to the zip archive.
            </summary>
            <remarks>
            <para>
            In some cases, applying the Deflate compression algorithm to an entry *may*
            result a slight increase in the size of the data.  This "inflation" can
            happen with previously compressed files, such as a zip, jpg, png, mp3, and
            so on; it results from adding Deflate framing data around incompressible data.
            Inflation can also happen with very small files. Applications may wish to
            avoid the use of compression in these cases. As well, applications may wish
            to avoid compression to save time.
            </para>
            <para>
            By default, the Compression library takes this approach to decide whether to
            apply compression: first it applies a heuristic, to determine whether it
            should try to compress a file or not.  The library checks the extension of
            the entry, and if it is one of a known list of uncompressible file types
            (mp3, zip, docx, and others), the library will not attempt to compress the
            entry.  The library does not actually Check the content of the entry.  If
            you name a text file "Text.mp3", and then attempt to add it to a zip
            archive, this library will, by default, not attempt to compress the entry,
            based on the extension of the filename.
            </para>
            <para>
            If this default behavior is not satisfactory, there are two options. First,
            the application can override it by setting this <see cref="P:Infragistics.Compression.ZipFile.WantCompression"/> callback.  This affords maximum control to
            the application.  With this callback, the application can supply its own
            logic for determining whether to apply the Deflate algorithm or not.  For
            example, an application may desire that files over 40mb in size are never
            compressed, or always compressed.  An application may desire that the first
            7 entries added to an archive are compressed, and the remaining ones are
            not.  The WantCompression callback allows the application full control, on
            an entry-by-entry basis.
            </para>
            <para>
            The second option for overriding the default logic regarding whether to
            apply compression is the ForceNoCompression flag.  If this flag is set to
            true, the compress-and-Check-sizes process as decribed above, is not done,
            nor is the callback invoked.  In other words, if you set ForceNoCompression
            to true, andalso set the WantCompression callback, only the
            ForceNoCompression flag is considered.
            </para>
            <para>
            This is how the library determines whether compression will be attempted for
            an entry.  If it is to be attempted, the library reads the entry, runs it
            through the deflate algorithm, and then checks the size of the result.  If
            applying the Deflate algorithm increases the size of the data, then the
            library discards the compressed bytes, re-reads the raw entry data, and
            stores the uncompressed file data into the zip archive, in compliance with
            the zip spec.  This is an optimization where smaller size is preferred over
            longer run times. The re-reading is gated on the <see cref="P:Infragistics.Compression.ZipFile.WillReadTwiceOnInflation"/> callback, if it is set. This callback
            applies independently of the WantCompression callback.
            </para>
            <para>
            If by the logic described above, compression is not to be attempted for an
            entry, the library reads the entry, and simply stores the entry data
            uncompressed.
            </para>
            </remarks>
            <seealso cref="P:Infragistics.Compression.ZipFile.WillReadTwiceOnInflation"/>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Count">
            <summary>
            Gets the number of entries in the Zip archive.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZipFile.Entries">
            <summary>
            Gets the collection of entries in the Zip archive.
            </summary>
            <value>The entries.</value>
            <remarks>
            If there are no entries in the current ZipFile, the value returned is a
            non-null zero-element collection.
            </remarks>
        </member>
        <member name="E:Infragistics.Compression.ZipFile.SaveProgress">
             <summary>
             An event handler invoked when a Save() starts, before and after each entry has been
             written to the archive, when a Save() completes, and during other Save events.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event, different properties on the
             SaveProgressEventArgs parameter are set.  The following TABLE 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a SaveProgressEventArgs with the given EventType.
             </para>
             
             <list type="TABLE">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
             
             <item>
             <term>ZipProgressEventType.SavingStarted</term>
             <description>Fired when ZipFile.Save() begins. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
             <description>Fired within ZipFile.Save(), just before writing data for each particular entry. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
             <description>Fired within ZipFile.Save(), just after having finished writing data for each 
             particular entry. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.SavingCompleted</term>
             <description>Fired when ZipFile.Save() has completed. 
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.SavingAfterSaveTempArchive</term>
             <description>Fired after the temporary file has been created.  This happens only
             when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.SavingBeforeRenameTempArchive</term>
             <description>Fired just before renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.SavingAfterRenameTempArchive</term>
             <description>Fired just after renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.SavingAfterCompileSelfExtractor</term>
             <description>Fired after a self-extracting archive has finished compiling. 
             This EventType is used only within SaveSelfExtractor().
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.Saving_BytesRead</term>
             <description>Set during the save of a particular entry, to update progress of the Save(). 
             When this EventType is set, the BytesTransferred is the number of bytes that have been Read from the 
             source stream.  The TotalBytesToTransfer is the number of bytes in the uncompressed file.
             </description>
             </item>
             
             </list>
             </remarks>
            
             <example>
             <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.SavingStarted)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
             
                 else if (e.EventType == ZipProgressEventType.SavingCompleted)
                 {
                     justHadByteUpdate= false; 
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
             
                 else if (e.EventType == ZipProgressEventType.SavingBeforeWriteEntry)
                 {
                     if (justHadByteUpdate) 
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",  
                                       e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
             
                 else if (e.EventType == ZipProgressEventType.SavingEntryBytesRead)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                     justHadByteUpdate= true;
                 }
             }
             
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress; 
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
            
             <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
                 Try 
                     Using zip As ZipFile = New ZipFile
                         AddHandler zip.SaveProgress, AddressOf MySaveProgress
                         zip.AddDirectory(directory)
                         zip.Save(targetZip)
                     End Using
                 Catch ex1 As Exception
                     Console.Error.WriteLine(("exception: " &amp; ex1.ToString))
                 End Try
             End Sub
             
             Private Shared justHadByteUpdate As Boolean = False
             
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.SavingStarted) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.SavingCompleted) Then
                     justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.SavingBeforeWriteEntry) Then
                     If justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
                     justHadByteUpdate = False
             
                 ElseIf (e.EventType Is ZipProgressEventType.SavingEntryBytesRead) Then
                     If justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
                                   e.TotalBytesToTransfer, _
                                   (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     justHadByteUpdate = True
                 End If
             End Sub
             </code>
            
             <para>
             This is an example of using the SaveProgress events in a WinForms app.
             </para>
             <code>
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // Check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." + 
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text), 
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.SavingAfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.SavingEntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.SavingCompleted:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.SavingAfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max > System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred >> _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred >= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
            
             </example>
        </member>
        <member name="E:Infragistics.Compression.ZipFile.ReadProgress">
             <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event being signaled, different properties on the
             ReadProgressEventArgs parameter are set.  The following TABLE 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a ReadProgressEventArgs with the given EventType.
             </para>
             
             <list type="TABLE">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
             
             <item>
             <term>ZipProgressEventType.ReadingStarted</term>
             <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.ReadingCompleted</term>
             <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.ReadingArchiveBytesRead</term>
             <description>Fired while reading, updates the number of bytes Read for the entire archive. 
             Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.ReadingBeforeReadEntry</term>
             <description>Indicates an entry is about to be Read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
             </item>
             
             <item>
             <term>ZipProgressEventType.ReadingAfterReadEntry</term>
             <description>Indicates an entry has just been Read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
             </description>
             </item>
            
             </list>
             </remarks>
        </member>
        <member name="E:Infragistics.Compression.ZipFile.AddProgress">
             <summary>
             An event handler invoked before, during, and after Adding entries to a zip archive.
             </summary>
            
             <remarks> Adding a large number of entries to a zip file can take a long
                 time.  For example, when calling <see cref="M:Infragistics.Compression.ZipEntry.CreateFile(System.String)"/> 
                 50,000 times, it could take 3 minutes or so.
                 This event handler allws an application to track the progress of the Add
                 operation.  </remarks>
            
             <example>
             <code lang="C#">
            
             int _numEntriesToAdd= 0;
             int _numEntriesAdded= 0;
             void AddProgressHandler(object sender, AddProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.AddingStarted:
                         Console.WriteLine("Adding files to the zip...");
                         break;
                      case ZipProgressEventType.AddingAfterAddEntry:
                         _numEntriesAdded++;
                         Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
                                                  _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
                         break;
                         
                     case ZipProgressEventType.AddingCompleted:
                         Console.WriteLine("Added all files");
                         break;
                 }
             }
                
             void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip.AddProgress += AddProgressHandler;
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
                     zip.BufferSize = 4096;
                     zip.SaveProgress += SaveProgressHandler;
                     zip.Save(ZipFileToCreate);
                 }
             }
                 
             </code>
             </example>
        </member>
        <member name="T:Infragistics.Compression.CRC32">
            <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the same polynomial
            used by Zip. This type is used internally by DotNetZip; it is generally not used
            directly by applications wishing to create, Read, or manipulate zip archive
            files.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.CRC32.#cctor">
            <summary>
            Initializes the <see cref="T:Infragistics.Compression.CRC32"/> class.
            pre-initialize the crc TABLE for speed of lookup.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
            Get the CRC32 for the given (word,byte) combo.  This is a computation
            defined by PKzip.
            </summary>
            <param name="w">The word to start with.</param>
            <param name="b">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Infragistics.Compression.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Infragistics.Compression.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Infragistics.Compression.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="P:Infragistics.Compression.CRC32.TotalBytesRead">
            <summary>
            indicates the total number of bytes Read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes Read, 
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either Read, or Write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
             
             <para>
             This class is intended primarily for use internally by the
             Compression library.
             </para>
             </remarks>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
            Instances returned from this constructor will leave the underlying stream
            open upon Close().
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            The constructor allows the caller to specify how to handle the underlying
            stream at close.
            </summary>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream 
            open upon close of the CrcCalculatorStream.; false otherwise.</param>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            A constructor allowing the specification of the length of the stream to Read.
            </summary>
            <remarks>
            Instances returned from this constructor will leave the underlying stream open
            upon Close().
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
            A constructor allowing the specification of the length of the stream to
            Read, as well as whether to keep the underlying stream open upon Close().
            </summary>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream 
            open upon close of the CrcCalculatorStream.; false otherwise.</param>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to Read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to Read</param>
            <returns>the number of bytes actually Read</returns>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not implemented.
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            Not implemented.
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Infragistics.Compression.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream. 
            </summary>
            <param name="buffer">the buffer from which to Write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to Write</param>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading. 
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.CanSeek">
            <summary>
            Indicates whether the stream supports seeking. 
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing. 
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.Length">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.Position">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.Crc32">
            <summary>
            Provides the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.LeaveOpen">
            <summary>
            Indicates whether the underlying stream will be Left open when the
            CrcCalculatorStream is Closed.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
             Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
             This is either the total number of bytes Read, or the total number of bytes
             written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="M:Infragistics.Compression.DeflateManager.SendTree(System.Int16[],System.Int32)">
            <summary>
            Send a literal or distance Tree in compressed form, using the codes in
            BlTree.
            </summary>
            <param name="tree">The Tree.</param>
            <param name="maxCode">The max code.</param>
        </member>
        <member name="M:Infragistics.Compression.DeflateManager.TrAlign">
            <summary>
            Send one empty static block to give enough Lookahead for inflate.
            This takes 10 bits, of which 7 may remain in the bit buffer.
            The current inflate code requires 9 bits of Lookahead. If the
            Last two codes for the previous block (real code plus EOB) were coded
            on 5 bits or less, inflate may have only 5+3 bits of Lookahead to decode
            the Last real code. In this case we send two empty static blocks instead
            of one. (There are no problems if the previous block is stored or fixed.)
            To simplify the code, we assume the worst case of Last real code encoded
            on one bit only.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.DeflateManager.TrTally(System.Int32,System.Int32)">
            <summary>
            Save the match info and tally the frequency counts. Return true if
            the current block must be flushed.
            </summary>
            <param name="dist">The dist.</param>
            <param name="lc">The lc.</param>
            <returns></returns>
        </member>
        <member name="M:Infragistics.Compression.DeflateManager.InitializeLazyMatch">
            <summary>
            Initialize lazy match.
            lm_init
            </summary>
        </member>
        <member name="M:Infragistics.Compression.DeflateManager.InitializeTreeData">
            <summary>
            Initializes the Tree data structures for a new zlib stream.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
             The DeflateStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds Deflate compression or decompression to any stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read</c> and <c>Write</c> operations.  Either compression or
             decompression can occur through either reading or writing. The compression
             format used is Deflate, which is documented in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "Deflate
             Compressed Data Format Specification version 1.3.".</para>
            
             <para>
             This class is similar to <see cref="T:Infragistics.Compression.ZlibStream"/>, except that <c>ZlibStream</c>
             adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - Zlib</see>
             framing bytes to a compressed stream when compressing, or expects the RFC1950
             framing bytes when decompressing. The <c>DeflateStream</c> does not.
             </para>
            
             </remarks>
            
             <seealso cref="T:Infragistics.Compression.DeflateStream"/>    
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode)">
            <summary>
            Create a DeflateStream using the specified CompressionMode.
            </summary>
            
            <remarks> When Mode is <c>CompressionMode.Compress</c>, the DeflateStream
            will use the default compression level. The "captive" stream will be closed
            when the DeflateStream is closed.  </remarks>
            
            <example>
            This example uses a DeflateStream to compress data from a file, and writes
            the compressed data to another file.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                {
                    using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n;
                        while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                        {
                            compressor.Write(buffer, 0, n);
                        }
                    }
                }
            }
            </code>
            <code lang="VB">
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                    Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                        Dim buffer As Byte() = New Byte(4096) {}
                        Dim n As Integer = -1
                        Do While (n &lt;&gt; 0)
                            If (n &gt; 0) Then
                                compressor.Write(buffer, 0, n)
                            End If
                            n = input.Read(buffer, 0, buffer.Length)
                        Loop
                    End Using
                End Using
            End Using
            </code>
            </example>
            <param name="stream">The stream which will be Read or written.</param>
            <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,Infragistics.Compression.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para> When Mode is <c>CompressionMode.Decompress</c>, the level parameter
             is ignored.  The "captive" stream will be closed when the DeflateStream is
             closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress, 
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0) 
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be Read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,System.Boolean)">
             <summary>
             Create a DeflateStream using the specified CompressionMode, and explicitly specify 
             whether the stream should be Left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para> This constructor allows the application to request that the captive
             stream remain open after the deflation or inflation occurs.  By default,
             after Close() is called on the stream, the captive stream is also closed. In
             some cases this is not desired, for example if the stream is a memory stream
             that will be re-Read after compression.  Specify true for the leaveOpen
             parameter to leave the stream open.  </para>
            
             <para>
             The DeflateStream will use the default compression level.
             </para>
             <para>
             See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">The stream which will be Read or written. This is called the 
             "captive" stream in other places in this documentation.</param>
            
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,Infragistics.Compression.CompressionLevel,System.Boolean)">
             <summary> Create a DeflateStream using the specified CompressionMode and the
             specified CompressionLevel, and explicitly specify whether the stream should
             be Left open after Deflation or Inflation.  </summary>
            
             <remarks>
            
             <para>
             When Mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored. 
             </para>
            
             <para>
             This constructor allows the application to request that the captive stream
             remain open after the deflation or inflation occurs.  By default, after Close()
             is called on the stream, the captive stream is also closed. In some cases this
             is not desired, for example if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be re-Read after compression.  Specify
             true for the leaveOpen parameter to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
             This example shows how to use a DeflateStream to compress data from a file, and store
             the compressed data into another file.
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0) 
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can Write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can Write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be Read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.  
            </summary>
            <remarks>
            This may or may not result in a Close() call on the captive stream. 
            See the constructors that have a leaveOpen parameter for more information.
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream. 
             </summary>
             <remarks>
            
             <para> If you wish to use the DeflateStream to compress data while reading,
             you can create a DeflateStream with CompressionMode.Compress, providing an
             uncompressed data stream.  Then call Read() on that DeflateStream, and the
             data Read will be compressed as you Read.  If you wish to use the
             DeflateStream to decompress data while reading, you can create a
             DeflateStream with CompressionMode.Decompress, providing a readable
             compressed data stream.  Then call Read() on that DeflateStream, and the
             data Read will be decompressed as you Read.  </para>
            
             <para>
             A DeflateStream can be used for Read() or Write(), but not both. 
             </para>
             </remarks>
             <param name="buffer">The buffer into which the Read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte Read.</param>
             <param name="count">the number of bytes to Read.</param>
             <returns>the number of bytes actually Read</returns>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this Method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this Method always throws a NotImplementedException.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Infragistics.Compression.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write data to the stream. 
            </summary>
            <remarks>
            <para>
            If you wish to use the DeflateStream to compress data while writing, you can
            create a DeflateStream with CompressionMode.Compress, and a writable output
            stream.  Then call Write() on that DeflateStream, providing uncompressed
            data as input.  The data sent to the output stream will be the compressed
            form of the data written.  If you wish to use the DeflateStream to
            decompress data while writing, you can create a DeflateStream with
            CompressionMode.Decompress, and a writable output stream.  Then call Write()
            on that stream, providing previously compressed data. The data sent to the
            output stream will be the decompressed form of the data written.
            </para>
            <para>
            A DeflateStream can be used for Read() or Write(), but not both. 
            </para>
            </remarks>
            <param name="buffer">The buffer holding data to Write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to Write.</param>
            <param name="count">the number of bytes to Write.</param>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be Read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.Length">
            <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.Position">
            <summary>
            The position of the stream pointer. 
            </summary>
            <remarks>
            Writing this property always throws a NotImplementedException. Reading will
            return the total bytes written out, if used in writing, or the total bytes 
            Read in, if used in reading.   The count may refer to compressed bytes or 
            uncompressed bytes, depending on how you've used the stream.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.  
            </summary>
            <remarks> See the Zlib documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.BufferSize">
             <summary>
             The size of the working buffer for the compression codec. 
             </summary>
            
             <remarks>
             <para>
             The working buffer is used for all stream operations.  The default size is 1024 bytes.
             The minimum size is 128 bytes. You may get better performance with a larger buffer.
             Then again, you might not.  You would have to test it.
             </para>
            
             <para>
             Set this before the first call to Read()  or Write() on the stream. If you try to set it 
             afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.Strategy">
            <summary>The Zlib strategy to be used during compression.</summary>
            <remarks>By tweaking this parameter, you may be able to optimize the compression for 
            data with particular characteristics.</remarks>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Infragistics.Compression.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="T:Infragistics.Compression.GZipStream">
             <summary>
             A class for compressing and decompressing Gzip streams.
             </summary>
             <remarks>
            
             <para>
             The GZipStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds Gzip compression or decompression to any stream.
             </para>
            
             <para> Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base
             Class Library, the GZipStream can compress while writing, or decompress
             while reading, but not vice versa.  The compression Method used is Gzip, which is
             documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC 1952</see>,
             "Gzip file format specification version 4.3".</para>
            
             <para> A GZipStream can be used to decompress data (through Read()) or to compress
             data (through Write()), but not both.  </para>
            
             <para> If you wish to use the GZipStream to compress data, you must wrap it around a
             Write-able stream. As you call Write() on the GZipStream, the data will be
             compressed into the Gzip format.  If you want to decompress data, you must wrap the
             GZipStream around a readable stream that contains an IETF RFC 1952-compliant stream.
             The data will be decompressed as you call Read() on the GZipStream.  </para>
            
             <para> Though the Gzip format allows data from multiple files to be concatenated
             together, this stream handles only a single segment of Gzip format, typically
             representing a single file.  </para>
            
             <para>
             This class is similar to <see cref="T:Infragistics.Compression.ZlibStream"/> and <see cref="T:Infragistics.Compression.DeflateStream"/>.
             <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Infragistics.Compression.DeflateStream"/>
             handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:Infragistics.Compression.DeflateStream"/>
             <seealso cref="T:Infragistics.Compression.ZlibStream"/>  
        </member>
        <member name="F:Infragistics.Compression.GZipStream.LastModified">
             <summary>
             The Last modified time for the Gzip stream.
             </summary>
            
             <remarks> Gzip allows the storage of a Last modified time with each Gzip entry.
             When compressing data, you can set this before the first call to Write().  When
             decompressing, you can retrieve this value any time after the first call to
             Read().  </remarks>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode)">
             <summary>
             Create a GZipStream using the specified CompressionMode. 
             </summary>
             <remarks>
            
             <para> When Mode is <c>CompressionMode.Compress</c>, the GZipStream will use the
             default compression level.  </para>
            
             <para> As noted in the class documentation, the CompressionMode (Compress or
             Decompress) also establishes the "direction" of the stream.  A GZipStream with
             CompressionMode.Compress works only through Write().  A GZipStream with
             CompressionMode.Decompress works only through Read().  </para>
            
             </remarks>
            
             <example>
             This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be Read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,Infragistics.Compression.CompressionLevel)">
             <summary>
             Create a GZipStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
             <remarks>
            
             <para>
             The CompressionMode (Compress or Decompress) also establishes the "direction" of the
             stream.  A GZipStream with CompressionMode.Compress works only through Write().  A
             GZipStream with CompressionMode.Decompress works only through Read().
             </para>
            
             </remarks>
            
             <example>
             This example shows how to use a GZipStream to compress a file into a .gz file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress, 
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be Read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,System.Boolean)">
             <summary>
             Create a GZipStream using the specified CompressionMode, and explicitly specify whether
             the stream should be Left open after Deflation or Inflation.
             </summary>
            
             <remarks>
             <para>
             This constructor allows the application to request that the captive stream remain open after
             the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
             captive stream is also closed. In some cases this is not desired, for example if the stream 
             is a memory stream that will be re-Read after compressed data has been written to it.  Specify true for the 
             leaveOpen parameter to leave the stream open. 
             </para>
             <para>
             As noted in the class documentation, 
             the CompressionMode (Compress or Decompress) also establishes the "direction" of the stream.  
             A GZipStream with CompressionMode.Compress works only through Write().  A GZipStream with 
             CompressionMode.Decompress works only through Read().
             </para>
             <para>
             The DeflateStream will use the default compression level.
             </para>
             <para>
             See the other overloads of this constructor for example code.
             </para>
             </remarks>
             <param name="stream">The stream which will be Read or written. This is called the 
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the base stream to remain open after inflation/deflation.</param>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,Infragistics.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Create a GZipStream using the specified CompressionMode and the specified CompressionLevel,
            and explicitly specify whether the stream should be Left open after Deflation or Inflation.
            </summary>
            <remarks>
            <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-Read after compressed data has been written to it.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
            <para>
            As noted in the class documentation, 
            the CompressionMode (Compress or Decompress) also establishes the "direction" of the stream.  
            A GZipStream with CompressionMode.Compress works only through Write().  A GZipStream with 
            CompressionMode.Decompress works only through Read().
            </para>
            </remarks>
            <example>
            This example shows how to use a DeflateStream to compress data.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(outputFile))
                {
                    using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n;
                        while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                        {
                            compressor.Write(buffer, 0, n);
                        }
                    }
                }
            }
            </code>
            <code lang="VB">
            Dim outputFile As String = (fileToCompress &amp; ".compressed")
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(outputFile)
                Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                    Dim buffer As Byte() = New Byte(4096) {}
                    Dim n As Integer = -1
                    Do While (n &lt;&gt; 0)
                        If (n &gt; 0) Then
                            compressor.Write(buffer, 0, n)
                        End If
                        n = input.Read(buffer, 0, buffer.Length)
                    Loop
                End Using
                End Using
            End Using
            </code>
            </example>
            <param name="stream">The stream which will be Read or written.</param>
            <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
            <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.  
            </summary>
            <remarks>
            This may or may not result in a Close() call on the captive stream. 
            See the ctor's with leaveOpen parameters for more information.
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read and decompress data from the source stream.
            </summary>
            <remarks>
            With a GZipStream, decompression is done through reading.
            </remarks>
            <example>
            <code>
            byte[] working = new byte[WORKING_BUFFER_SIZE];
            using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
            {
                using (Stream decompressor= new GZipStream(input, CompressionMode.Decompress, true))
                {
                    using (var output = System.IO.File.Create(_DecompressedFile))
                    {
                        int n;
                        while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                        {
                            output.Write(working, 0, n);
                        }
                    }
                }
            }
            </code>
            </example>
            <param name="buffer">The buffer into which the decompressed data should be placed.</param>
            <param name="offset">the offset within that data array to put the first byte Read.</param>
            <param name="count">the number of bytes to Read.</param>
            <returns>the number of bytes actually Read</returns>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this Method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.SetLength(System.Int64)">
            <summary>
            Calling this Method always throws a NotImplementedException.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Infragistics.Compression.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write data to the stream. 
            </summary>
            <remarks>
            <para>
            If you wish to use the GZipStream to compress data while writing, you can create a
            GZipStream with CompressionMode.Compress, and a writable output stream.  Then call
            Write() on that GZipStream, providing uncompressed data as input.  The data sent
            to the output stream will be the compressed form of the data written.  
            </para>
            <para>
            A GZipStream can be used for Read() or Write(), but not both. Writing implies compression. 
            Reading implies decompression.
            </para>
            </remarks>
            <param name="buffer">The buffer holding data to Write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to Write.</param>
            <param name="count">the number of bytes to Write.</param>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be Read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.Length">
            <summary>
            Reading this property always throws a NotImplementedException.
            </summary>  
        </member>
        <member name="P:Infragistics.Compression.GZipStream.Position">
            <summary>
            The position of the stream pointer. 
            </summary>
            <remarks>
            Writing this property always throws a NotImplementedException. Reading will
            return the total bytes written out, if used in writing, or the total bytes 
            Read in, if used in reading.   The count may refer to compressed bytes or 
            uncompressed bytes, depending on how you've used the stream.
            </remarks>  
        </member>
        <member name="P:Infragistics.Compression.GZipStream.BufferSize">
             <summary>
             The size of the working buffer for the compression codec. 
             </summary>
            
             <remarks>
             <para>
             The working buffer is used for all stream operations.  The default size is 1024 bytes.
             The minimum size is 128 bytes. You may get better performance with a larger buffer.
             Then again, you might not.  You would have to test it.
             </para>
            
             <para>
             Set this before the first call to Read()  or Write() on the stream. If you try to set it 
             afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.Comment">
             <summary>
             The Comment on the Gzip stream.
             </summary>
             <remarks>
             <para>
             The Gzip format allows for each file to optionally have an associated comment stored with the
             file.  The comment is encoded with the ISO-8859-1 code page.  To include a comment in
             a Gzip stream you create, set this property before calling Write() for the first time
             on the GZipStream.  
             </para>
            
             <para>
             When using GZipStream to decompress, you can retrieve this property after the first
             call to Read().  If no comment has been set in the Gzip bytestream, the Comment
             property will return null (Nothing in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.Crc32">
            <summary>
            The CRC on the Gzip stream. 
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't Need to look at this property.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.FileName">
            <summary>
            The FileName for the Gzip stream.
            </summary>
            <remarks>
            <para>
            The Gzip format optionally allows each file to have an associated filename.  When
            compressing data (through Write()), set this FileName before calling Write() the first
            time on the GZipStream.  The actual filename is encoded into the Gzip bytestream with
            the ISO-8859-1 code page, according to RFC 1952. It is the application's responsibility to 
            insure that the FileName can be encoded and decoded correctly with this code page. 
            </para>
            <para>
            When decompressing (through Read()), you can retrieve this value any time after the
            first Read().  In the case where there Was no filename encoded into the Gzip
            bytestream, the property will return null (Nothing in VB).
            </para>
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.  
            </summary>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.TotalIn">
            <summary>
            Returns the total number of bytes input so far.
            </summary>
            <value>The total number of bytes input so far.</value>
        </member>
        <member name="P:Infragistics.Compression.GZipStream.TotalOut">
            <summary>
            Returns the total number of bytes output so far.
            </summary>
            <value>The total number of bytes output so far.</value>
        </member>
        <member name="T:Infragistics.Compression.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library. 
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Infragistics.Compression.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Infragistics.Compression.SharedUtils.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Infragistics.Compression.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified Index.</summary>
            <param name="sourceTextReader">The source TextReader to Read from</param>
            <param name="target">Contains the array of characteres Read from the source TextReader.</param>
            <param name="start">The starting Index of the target array.</param>
            <param name="count">The maximum number of characters to Read from the source TextReader.</param>
            <returns>The number of characters Read. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the End of the stream is reached.</returns>
        </member>
        <member name="T:Infragistics.Compression.Adler">
            <summary>
            Computes an Adler-32 checksum. 
            </summary>
            <remarks>
            The Adler checksum is similar to a CRC checksum, but faster to compute, though less
            reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
            is a required part of the "Zlib" standard.  Applications will almost never Need to
            use this class directly.
            </remarks>
        </member>
        <member name="T:Infragistics.Compression.ZlibCodec">
             <summary>
             Encoder and Decoder for Zlib and Deflate (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the Zlib format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - Zlib</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - Deflate</see>.
             </remarks>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.NextIn">
            <summary>
            An Index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes Read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.NextOut">
            <summary>
            An Index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression Mode.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding Window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k Window.  
            </remarks>
        </member>
        <member name="F:Infragistics.Compression.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by Zlib is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.#ctor(Infragistics.Compression.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.Deflate(Infragistics.Compression.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this Method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(ZlibConstants.Z_NO_FLUSH);
            
                    if (rc != ZlibConstants.ZOk &amp;&amp; rc != ZlibConstants.ZStreamEnd)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(ZlibConstants.Z_FINISH);
            
                    if (rc != ZlibConstants.ZStreamEnd &amp;&amp; rc != ZlibConstants.ZOk)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>ZOk if everything goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>ZOk if everything goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the Zlib header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to Read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>ZOk if everything goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of Window bits. 
            </summary>
            <param name="windowBits">The number of Window bits to use. If you Need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to Read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a Zlib
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a Deflate or
             Gzip stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of Window bits to use. If you Need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>ZOk if everything goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.Inflate(Infragistics.Compression.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this Method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(ZlibConstants.Z_NO_FLUSH);
             
                     if (rc != ZlibConstants.ZOk &amp;&amp; rc != ZlibConstants.ZStreamEnd)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(ZlibConstants.Z_FINISH);
             
                     if (rc != ZlibConstants.ZStreamEnd &amp;&amp; rc != ZlibConstants.ZOk)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>ZOk if everything goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX Window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(ZlibConstants.Z_NO_FLUSH);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(ZlibConstants.Z_FINISH);
               if (rc == ZlibConstants.ZStreamEnd) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>ZOk if all goes well. You generally don't Need to Check the return code.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeDeflate(Infragistics.Compression.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum Window bits (15) and the specified
            CompressionLevel.  It will emit a Zlib stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeDeflate(Infragistics.Compression.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum Window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a Zlib
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeDeflate(Infragistics.Compression.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of Window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of Window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of Window bits to use.  If you don't know what this means, don't use this Method.</param>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.InitializeDeflate(Infragistics.Compression.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of Window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of Window bits to use.  If you don't know what this means, don't use this Method.</param>
             <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>ZOk if everything goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.SetDeflateParams(Infragistics.Compression.CompressionLevel,Infragistics.Compression.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="M:Infragistics.Compression.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>ZOk if all goes well.</returns>
        </member>
        <member name="P:Infragistics.Compression.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't Need to look at this.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of Window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of Window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.ZOk">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.ZStreamEnd">
            <summary>
            Indicates that the Last operation reached the End of the stream.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.ZNeedDict">
            <summary>
            The operation ended in Need of a dictionary. 
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.ZStreamError">
            <summary>
            There Was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.ZDataError">
            <summary>
            There Was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.ZBufError">
            <summary>
            There Was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Infragistics.Compression.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Infragistics.Compression.ZlibStream">
             <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
             <remarks>
            
             <para>
             The ZlibStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds Zlib compression or decompression to any
             stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read</c> and <c>Write</c> operations.  Either compression or
             decompression can occur through either reading or writing. The compression
             format used is Zlib, which is documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "Zlib Compressed
             Data Format Specification version 3.3". This implementation of Zlib always uses
             Deflate as the compression Method.  (see <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "Deflate
             Compressed Data Format Specification version 1.3.") </para>
            
             <para>
             The Zlib format allows for varying compression methods, Window sizes, and dictionaries.
             This implementation always uses the Deflate compression Method, a preset dictionary,
             and 15 Window bits by default.  
             </para>
            
             <para>
             This class is similar to <see cref="T:Infragistics.Compression.DeflateStream"/>, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Infragistics.Compression.GZipStream"/>.
             </para>
             </remarks>
             <seealso cref="T:Infragistics.Compression.DeflateStream"/>
             
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode)">
             <summary>
             Create a ZlibStream using the specified CompressionMode.
             </summary>
             <remarks>
            
             <para> When Mode is <c>CompressionMode.Compress</c>, the ZlibStream will use
             the default compression level. The "captive" stream will be closed when the
             ZlibStream is closed.</para>
            
             </remarks>
            
             <example>
             This example uses a ZlibStream to compress a file, and writes the compressed 
             data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be Read or written.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,Infragistics.Compression.CompressionLevel)">
             <summary>
             Create a ZlibStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
             When Mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             The "captive" stream will be closed when the ZlibStream is closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a ZlibStream to compress data from a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress, 
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream to be Read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,System.Boolean)">
             <summary>
             Create a ZlibStream using the specified CompressionMode, and explicitly specify 
             whether the captive stream should be Left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para> When Mode is <c>CompressionMode.Compress</c>, the ZlibStream will use
             the default compression level.  </para>
            
             <para>
             This constructor allows the application to request that the captive stream
             remain open after the deflation or inflation occurs.  By default, after Close()
             is called on the stream, the captive stream is also closed. In some cases this
             is not desired, for example if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be re-Read after compression.  Specify
             true for the leaveOpen parameter to leave the stream open.
             </para>
            
             <para>
             See the other overloads of this constructor for example code.
             </para>
             
             </remarks>
             
             <param name="stream">The stream which will be Read or written. This is called the 
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.#ctor(System.IO.Stream,Infragistics.Compression.CompressionMode,Infragistics.Compression.CompressionLevel,System.Boolean)">
             <summary>
             Create a ZlibStream using the specified CompressionMode and the specified
             CompressionLevel, and explicitly specify whether the stream should be Left open
             after Deflation or Inflation.
             </summary>
             
             <remarks>
            
             <para>
             This constructor allows the application to request that the captive stream
             remain open after the deflation or inflation occurs.  By default, after Close()
             is called on the stream, the captive stream is also closed. In some cases this
             is not desired, for example if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be re-Read after compression.  Specify
             true for the leaveOpen parameter to leave the stream open.
             </para>
            
             <para>
             When Mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored. 
             </para>
            
             </remarks>
             
             <example>
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can Write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can Write additional data to the output stream here.
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be Read or written.</param>
            
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            
             <param name="leaveOpen">
             true if the application would like the stream to remain open after inflation/deflation.
             </param>
            
             <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is effective only when
             Mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.  
            </summary>
            <remarks>
            This may or may not result in a Close() call on the captive stream. 
            See the constructors that have a leaveOpen parameter for more information.
            </remarks>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream. 
             </summary>
            
             <remarks>
            
             <para>
             If you wish to use the ZlibStream to compress data while reading, you can create a
             ZlibStream with CompressionMode.Compress, providing an uncompressed data stream.  Then
             call Read() on that ZlibStream, and the data Read will be compressed.  If you wish to
             use the ZlibStream to decompress data while reading, you can create a ZlibStream with
             CompressionMode.Decompress, providing a readable compressed data stream.  Then call
             Read() on that ZlibStream, and the data will be decompressed as it is Read.
             </para>
            
             <para>
             A ZlibStream can be used for Read() or Write(), but not both. 
             </para>
             </remarks>
             <param name="buffer">The buffer into which the Read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte Read.</param>
             <param name="count">the number of bytes to Read.</param>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this Method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this Method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream. 
             </summary>
            
             <remarks>
            
             <para>
             If you wish to use the ZlibStream to compress data while writing, you can create a
             ZlibStream with CompressionMode.Compress, and a writable output stream.  Then call
             Write() on that ZlibStream, providing uncompressed data as input.  The data sent to
             the output stream will be the compressed form of the data written.  If you wish to use
             the ZlibStream to decompress data while writing, you can create a ZlibStream with
             CompressionMode.Decompress, and a writable output stream.  Then call Write() on that
             stream, providing previously compressed data. The data sent to the output stream will
             be the decompressed form of the data written.
             </para>
            
             <para>
             A ZlibStream can be used for Read() or Write(), but not both. 
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to Write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to Write.</param>
             <param name="count">the number of bytes to Write.</param>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.CompressString(System.String)">
            <summary>
            Compress a string into a byte array.
            </summary>
            <remarks>
            Uncompress it with <see cref="M:Infragistics.Compression.ZlibStream.UncompressString(System.Byte[])"/>.
            </remarks>
            <seealso cref="M:Infragistics.Compression.ZlibStream.UncompressString(System.Byte[])"/>
            <param name="s">
            A string to compress.  The string will first be encoded
            using UTF8, then compressed.
            </param>
        </member>
        <member name="M:Infragistics.Compression.ZlibStream.UncompressString(System.Byte[])">
            <summary>
            Uncompress a byte array into a single string.
            </summary>
            <seealso cref="M:Infragistics.Compression.ZlibStream.CompressString(System.String)"/>
            <param name="compressed">
            A buffer containing Zlib-compressed data.  
            </param>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be Read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.Length">
            <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.Position">
            <summary>
            The position of the stream pointer. 
            </summary>
            <remarks>
            Writing this property always throws a NotImplementedException. Reading will
            return the total bytes written out, if used in writing, or the total bytes 
            Read in, if used in reading.   The count may refer to compressed bytes or 
            uncompressed bytes, depending on how you've used the stream.
            </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.  
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.BufferSize">
             <summary>
             The size of the working buffer for the compression codec. 
             </summary>
            
             <remarks>
             <para>
             The working buffer is used for all stream operations.  The default size is 1024 bytes.
             The minimum size is 128 bytes. You may get better performance with a larger buffer.
             Then again, you might not.  You would have to test it.
             </para>
            
             <para>
             Set this before the first call to Read()  or Write() on the stream. If you try to set it 
             afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Infragistics.Compression.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
    </members>
</doc>
